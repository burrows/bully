def ok(expr, msg)
  if expr
    puts 'OK: ' + msg
  else
    puts 'FAIL: ' + msg
  end
end

def fail(msg)
  puts 'FAIL: ' + msg
end

#-------------------------------------------------------------------------------
# Conditionals
#-------------------------------------------------------------------------------
x = true
y = false
r = nil

if x
  r = 'if'
else
  r = 'else'
end
ok(r == 'if', 'if body should be executed')

if y
  r = 'if'
else
  r = 'else'
end
ok(r == 'else', 'else body should be executed')

if y
  r = 'if'
elsif x
  r = 'elsif'
else
  r = 'else'
end
ok(r == 'elsif', 'elsif body should be executed')

x = if true
      126
    end
ok(x == 126, 'if should evaluate to value of body if expression is true')

x = if false
      21
    else
      22
    end
ok(x == 22, 'if should evaluate to value of else body if expression is false')

x = if false
      17
    elsif true
      18
    else
      19
    end
ok(x == 18, 'if should evaluate to value of elsif body with true expression')

x = if false
      9
    end
ok(x == nil, 'if should evaluate to nil if expression is false and no else')

#-------------------------------------------------------------------------------
# Exceptions
#-------------------------------------------------------------------------------
rescue_run = false
begin
  raise 'something'
  fail 'executed code after raise'
rescue StandardError => e
  rescue_run = true
end
ok(rescue_run == true, 'should rescue StandardError')

rescue_run = false
else_run = false
begin
  y = 1 + 1
rescue
  rescue_run = true
else
  else_run = true
end
ok(rescue_run == false, 'rescue should not be executed')
ok(else_run == true, 'else should be executed')

rescue_run = false
else_run = false
begin
  raise 'error'
rescue
  rescue_run = true
else
  else_run = true
end
ok(rescue_run == true, 'rescue should be executed')
ok(else_run == false, 'else should not be executed')

rescue_run = false
else_run = false
ensure_run = false
begin
  raise 'error'
rescue
  rescue_run = true
else
  else_run = true
ensure
  ensure_run = true
end
ok(rescue_run == true, 'rescue should be executed')
ok(else_run == false, 'else should not be executed')
ok(ensure_run == true, 'ensure should be executed')

rescue_run = false
else_run = false
ensure_run = false
begin
  y = 2 + 2
rescue
  rescue_run = true
else
  else_run = true
ensure
  ensure_run = true
end
ok(rescue_run == false, 'rescue should not be executed')
ok(else_run == true, 'else should be executed')
ok(ensure_run == true, 'ensure should be executed')

arg_rescue = false
name_rescue = false
begin
  raise NameError
rescue ArgumentError
  arg_rescue = true
rescue NameError
  name_rescue = true
end
ok(arg_rescue == false, 'ArgumentError should not be rescued')
ok(name_rescue == true, 'NameError should be rescued')

def replace_error
  begin
    raise ArgumentError
  rescue
    raise NameError
  end
end

arg_rescue = false
name_rescue = false
begin
  replace_error
rescue ArgumentError
  arg_rescue = true
rescue NameError
  name_rescue = true
end
ok(arg_rescue == false, 'ArgumentError should not bubble')
ok(name_rescue == true, 'NameError should bubble')

begin
  raise RuntimeError, 'foo bar'
rescue ArgumentError => argument_error
rescue RuntimeError => runtime_error
end
ok(argument_error == nil, 'argument_error local var should not be set')
ok(runtime_error.is_a?(RuntimeError) == true, 'runtime_error local var should be set to exception object')
ok(runtime_error.message == 'foo bar', 'runtime_error local var should be set to exception object')

x = 1 + begin
  2
end
ok(x == 3, 'begin block should yield result')

x = 1 + begin
  100 + raise
  2
rescue
  3
end
ok(x == 4, 'begin block should yield result of rescue when an exception is raised')

x = 1 + begin
  2
rescue
  3
else
  4
end
ok(x == 5, 'begin block should yield result of else body when no exception is raised')

x = 1 + begin
  2
rescue
  3
ensure
  4
end
ok(x == 3, 'begin block should yield result of body when no exception is raised and there is an ensure block')

x = 0
begin
  x = x + 1
  raise 
rescue
  if x == 1
    retry
  end
end
ok(x == 2, 'retry should re-run the begin body')

x = 0
y = begin
  x = x + 1
  raise if x == 1
  10
rescue
  retry
end
ok(y == 10, 'begin should yield value of body when retry is run')

x = 0
y = begin
  x = x + 1
  raise
  10
rescue
  if x == 1
    retry
  end
  27
end
ok(y == 27, 'begin should yield value of rescue block when raise occurs after a retry')

#-------------------------------------------------------------------------------
# Methods
#-------------------------------------------------------------------------------
def req_only(req1, req2)
  [req1, req2]
end

def opt_only(opt1=:opt1, opt2=:opt2)
  [opt1, opt2]
end

def splat_only(*splat)
  splat
end

def req_and_opt(req1, req2, opt1=:opt1, opt2=:opt2)
  [req1, req2, opt1, opt2]
end

def req_opt_and_splat(req1, req2, opt1=:opt1, opt2=:opt2, *splat)
  [req1, req2, opt1, opt2, splat]
end

ok(req_only(1,2) == [1,2], 'required args should be set')
ok(opt_only == [:opt1, :opt2], 'optional args should set defaults when no arg is given')
ok(opt_only(1) == [1, :opt2], 'optional args should set defaults when some args are given')
ok(opt_only(1, 2) == [1, 2], 'optional args should set no defaults when all args are given')
ok(splat_only(1,2,3) == [1,2,3], 'splat args should suck all remaining args into an array')
ok(req_and_opt(10,20) == [10, 20, :opt1, :opt2], 'optional args with required opts 1')
ok(req_and_opt(10,20,30) == [10, 20, 30, :opt2], 'optional args with required opts 2')
ok(req_and_opt(10,20,30,40) == [10, 20, 30, 40], 'optional args with required opts 3')
ok(req_opt_and_splat(10,20) == [10, 20, :opt1, :opt2, []], 'required optional and splat params 1')
ok(req_opt_and_splat(10,20,30,40) == [10, 20, 30, 40, []], 'required optional and splat params 2')
ok(req_opt_and_splat(10,20,30,40,50,60,70) == [10, 20, 30, 40, [50,60,70]], 'required optional and splat params 3')

begin
  req_only(1)
  fail('fewer than min args should raise ArgumentError to req_only')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 2)', 'ArgumentError message when too few args to req_only')
end

begin
  req_only(1,2,3)
  fail('more than max args should raise ArgumentError to req_only')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (3 for 2)', 'ArgumentError message when too many args to req_only')
end

begin
  req_and_opt(1)
  fail('fewer than min args should raise ArgumentError to req_and_opt')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 2)', 'ArgumentError message when too few args to req_and_opt')
end

begin
  req_and_opt(1,2,3,4,5,6)
  fail('more than max args should raise ArgumentError to req_and_opt')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (6 for 4)', 'ArgumentError message when too many args to req_and_opt')
end

begin
  req_opt_and_splat(1)
  fail('fewer than min args should raise ArgumentError to req_opt_and_splat')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 2)', 'ArgumentError message when too few args to req_opt_and_splat')
end

begin
  req_opt_and_splat(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  ok(true, 'no upper bound and number of args to req_opt_and_splat')
rescue ArgumentError => e
  fail('args with splat should not raise ArgumentError for too many params')
end

begin
  "foo".to_s(1)
  fail('calling a method defined in JS should check number of arguments')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 0)', 'methods implemented in JS should check number of arguments')
end

o = Object.new
begin
  o.stuff
  fail('unknown method should raise exception')
rescue NoMethodError => e
  ok(e.message.slice(0, 24)  == "undefined method 'stuff'", 'unknown method should raise NoMethodError')
end

#-------------------------------------------------------------------------------
# Singleton Methods
#-------------------------------------------------------------------------------
o = Object.new

def o.foo
  'singleton#foo'
end

def o.bar(a, b)
  [a, b]
end

ok(o.respond_to?(:foo) == true, "defining a a singleton method on an object makes the method available to the object")
ok(o.foo == 'singleton#foo', 'objects can call their singleton methods')
ok(Object.new.respond_to?(:foo) == false, "objects do not have access to singleton methods defined on another object")
ok(o.bar(:x, :y) == [:x, :y], 'singleton methods can accept parameters')

#-------------------------------------------------------------------------------
# Modules and Classes
#-------------------------------------------------------------------------------

class Class1
  def bar
    'Class1#bar'
  end

  def baz
    'Class1#baz'
  end
end

ok(Class1.is_a?(Class) == true, 'class definitions should create an instance of Class')
ok(Class1.superclass == Object, 'class definitions without a superclass should have a superclass of Object')
ok(Class1.new.bar == 'Class1#bar', 'should be able to define classes with instance methods')
ok(Class1.instance_methods(false) == [:bar, :baz], 'class should know its instance methods')

ok((class Class2; 8; 9; end) == 9, 'class definitions should yield value of last expression of body')

class Class3 < Class1
  def baz
    'Class3#baz'
  end
end

ok(Class3.superclass == Class1, 'class definitions with a superclass')
ok(Class3.new.bar == 'Class1#bar', 'child classes can access methods implemented in the superclass')
ok(Class3.new.baz == 'Class3#baz', 'child classes can override methods implemented in the superclass')

class Class1
  def quux; end
end

ok(Class1.instance_methods(false) == [:bar, :baz, :quux], 'classes should be able to be reopened')

begin
  class Class1 < Class2; end
  fail("changing a class' superclass should raise a TypeError exception")
rescue TypeError => e
  ok(e.message == 'superclass mismatch for class Class1', "changing a class' superclass should raise a TypeError exception")
end

module SomeModule; end
begin
  class SomeModule; end
  fail('trying to change a module to a class should raise a TypeError exception')
rescue TypeError => e
  ok(e.message == 'SomeModule is not a class', 'trying to change a module to a class should raise a TypeError exception')
end

begin
  class ClassSubclass < Class; end
  fail("should not be able to subclass Class")
rescue TypeError => e
  ok(e.message == "can't make subclass of Class", "should not be able to subclass Class")
end

begin
  class BadSuperclass < SomeModule; end
  fail('superclass must be a Class')
rescue TypeError => e
  ok(e.message == 'wrong argument type Module (expected Class)', 'superclass must be a Class')
end

module Module1
  def foo
    'Module1#foo'
  end

  def bar
    'Module1#bar'
  end
end

ok(Module1.is_a?(Module) == true, 'module definitions should create an instance of Module')
ok(Module1.instance_methods(false) == [:foo, :bar], 'module should know its instance methods')

class Class4
  include Module1
end

ok(Class4.new.foo == 'Module1#foo', 'including a module in a class should make its instance methods available to instances of the class')

class SomeClass; end
begin
  module SomeClass; end
  fail('trying to change a class to a module should raise a TypeError exception')
rescue TypeError => e
  ok(e.message == 'SomeClass is not a module', 'trying to change a class to a module should raise a TypeError exception')
end

o = Object.new
class << o
  def foo
    'singleton#foo'
  end
end

ok(o.respond_to?(:foo) == true, "defining a method in an object's singleton class makes the method available to the object")
ok(o.foo == 'singleton#foo', 'objects can call methods defined on their singleton class')
ok(Object.new.respond_to?(:foo) == false, "other objects do not have access to methods defined in another object's singleton class")

class IVarClass
  def set_foo(v)
    @foo = v
  end

  def foo
    @foo
  end
end

x = IVarClass.new
ok(x.foo == nil, 'uninitialized instance variables should yield nil')
ok((x.set_foo(9)) == 9, 'setting an instance variable should yield the value')
ok(x.foo == 9, 'instance methods should be able to set instance variables')

class CallAssignClass
  def initialize(*a)
    @a = a
  end

  def foo=(v)
    @foo = v
  end

  def weird_foo=(v)
    @foo = v
    :garbage
  end

  def foo
    @foo
  end

  def a
    @a
  end

  def []=(i, v)
    @a[i] = v
  end

  def [](i)
    @a[i]
  end
end

x = CallAssignClass.new(:a, :b, :c, :d)
x.foo = 23
ok(x.foo == 23, 'assignment methods should be able to set instance variables')
ok((x.foo = 24) == 24, 'assignment methods should return the value being assigned')
ok((x.weird_foo = 25) == 25, 'assignment methods should return the value being assigned even if the method actually returns something else')
x[2] = :z 
ok(x.a == [:a, :b, :z, :d], 'bracket call assignment methods should get the index and value as arguments')
ok((x[1] = :y) == :y, 'bracket call assigment methods should return the value being assigned')

#-------------------------------------------------------------------------------
# Inheritance
#-------------------------------------------------------------------------------
class Parent
  def self.class_method
    'Parent.class_method'
  end

  def foo
    'Parent#foo'
  end

  def bar
    'Parent#bar'
  end

  def with_args1(a, b)
    [a, b]
  end

  def with_args2(a, b)
    [a, b]
  end

  def with_args2(a, b)
    [a, b]
  end

  def splat_arg(*a)
    a
  end
end

class Child < Parent
  def bar
    super + ', Child#bar'
  end

  def with_args1(a, b)
    super
  end

  def with_args2(a, b)
    super(a - 1, b - 1)
  end

  def splat_arg(a, b)
    super()
  end
end

class GrandChild < Child
  def self.class_method
    super + ', GrandChild.class_method'
  end

  def foo
    super + ', GrandChild#foo'
  end

  def bar
    super + ', GrandChild#bar'
  end

  def quux
    super
  end
end

ok(Child.new.bar == 'Parent#bar, Child#bar', 'instance methods can call superclass method')
ok(GrandChild.class_method == 'Parent.class_method, GrandChild.class_method', 'class methods can call superclass method')
ok(GrandChild.new.bar == 'Parent#bar, Child#bar, GrandChild#bar', 'instance methods can call superclass methods spanning multiple levels')
ok(GrandChild.new.foo == 'Parent#foo, GrandChild#foo', 'instance methods can call superclass methods that skip a class')
ok(Child.new.with_args1(8, 9) == [8, 9], 'calling super with no parens or args passes method arguments to super method')
ok(Child.new.with_args2(8, 9) == [7, 8], 'calling super with args passes those args to the super method')
ok(Child.new.splat_arg(8, 9) == [], 'calling super with parens and no args passes no args to the super method')

begin
  GrandChild.new.quux
  fail('calling super when no superclass method exists should raise NoMethodError')
rescue NoMethodError => e
  ok(e.message.slice(0, 51) == "super: no superclass method 'quux' for #<GrandChild", 'calling super when no superclass method exists should raise NoMethodError')
end

