def ok(expr, msg)
  if expr
    puts 'OK: ' + msg
  else
    puts 'FAIL: ' + msg
  end
end

def fail(msg)
  puts 'FAIL: ' + msg
end

#-------------------------------------------------------------------------------
# Conditionals
#-------------------------------------------------------------------------------
x = true
y = false
r = nil

if x
  r = 'if'
else
  r = 'else'
end
ok(r == 'if', 'if body should be executed')

if y
  r = 'if'
else
  r = 'else'
end
ok(r == 'else', 'else body should be executed')

if y
  r = 'if'
elsif x
  r = 'elsif'
else
  r = 'else'
end
ok(r == 'elsif', 'elsif body should be executed')

x = if true
      126
    end
ok(x == 126, 'if should evaluate to value of body if expression is true')

x = if false
      21
    else
      22
    end
ok(x == 22, 'if should evaluate to value of else body if expression is false')

x = if false
      17
    elsif true
      18
    else
      19
    end
ok(x == 18, 'if should evaluate to value of elsif body with true expression')

x = if false
      9
    end
ok(x == nil, 'if should evaluate to nil if expression is false and no else')

#-------------------------------------------------------------------------------
# Exceptions
#-------------------------------------------------------------------------------
rescue_run = false
begin
  raise 'something'
  fail 'executed code after raise'
rescue StandardError => e
  rescue_run = true
end
ok(rescue_run == true, 'should rescue StandardError')

rescue_run = false
else_run = false
begin
  y = 1 + 1
rescue
  rescue_run = true
else
  else_run = true
end
ok(rescue_run == false, 'rescue should not be executed')
ok(else_run == true, 'else should be executed')

rescue_run = false
else_run = false
begin
  raise 'error'
rescue
  rescue_run = true
else
  else_run = true
end
ok(rescue_run == true, 'rescue should be executed')
ok(else_run == false, 'else should not be executed')

rescue_run = false
else_run = false
ensure_run = false
begin
  raise 'error'
rescue
  rescue_run = true
else
  else_run = true
ensure
  ensure_run = true
end
ok(rescue_run == true, 'rescue should be executed')
ok(else_run == false, 'else should not be executed')
ok(ensure_run == true, 'ensure should be executed')

rescue_run = false
else_run = false
ensure_run = false
begin
  y = 2 + 2
rescue
  rescue_run = true
else
  else_run = true
ensure
  ensure_run = true
end
ok(rescue_run == false, 'rescue should not be executed')
ok(else_run == true, 'else should be executed')
ok(ensure_run == true, 'ensure should be executed')

arg_rescue = false
name_rescue = false
begin
  raise NameError
rescue ArgumentError
  arg_rescue = true
rescue NameError
  name_rescue = true
end
ok(arg_rescue == false, 'ArgumentError should not be rescued')
ok(name_rescue == true, 'NameError should be rescued')

def replace_error
  begin
    raise ArgumentError
  rescue
    raise NameError
  end
end

arg_rescue = false
name_rescue = false
begin
  replace_error
rescue ArgumentError
  arg_rescue = true
rescue NameError
  name_rescue = true
end
ok(arg_rescue == false, 'ArgumentError should not bubble')
ok(name_rescue == true, 'NameError should bubble')

begin
  raise RuntimeError, 'foo bar'
rescue ArgumentError => argument_error
rescue RuntimeError => runtime_error
end
ok(argument_error == nil, 'argument_error local var should not be set')
ok(runtime_error.is_a?(RuntimeError) == true, 'runtime_error local var should be set to exception object')
ok(runtime_error.message == 'foo bar', 'runtime_error local var should be set to exception object')

x = 1 + begin
  2
end
ok(x == 3, 'begin block should yield result')

x = 1 + begin
  100 + raise
  2
rescue
  3
end
ok(x == 4, 'begin block should yield result of rescue when an exception is raised')

x = 1 + begin
  2
rescue
  3
else
  4
end
ok(x == 5, 'begin block should yield result of else body when no exception is raised')

x = 1 + begin
  2
rescue
  3
ensure
  4
end
ok(x == 3, 'begin block should yield result of body when no exception is raised and there is an ensure block')

x = 0
begin
  x = x + 1
  raise 
rescue
  if x == 1
    retry
  end
end
ok(x == 2, 'retry should re-run the begin body')

x = 0
y = begin
  x = x + 1
  raise if x == 1
  10
rescue
  retry
end
ok(y == 10, 'begin should yield value of body when retry is run')

x = 0
y = begin
  x = x + 1
  raise
  10
rescue
  if x == 1
    retry
  end
  27
end
ok(y == 27, 'begin should yield value of rescue block when raise occurs after a retry')

#-------------------------------------------------------------------------------
# Methods
#-------------------------------------------------------------------------------
def req_only(req1, req2)
  [req1, req2]
end

def opt_only(opt1=:opt1, opt2=:opt2)
  [opt1, opt2]
end

def splat_only(*splat)
  splat
end

def req_and_opt(req1, req2, opt1=:opt1, opt2=:opt2)
  [req1, req2, opt1, opt2]
end

def req_opt_and_splat(req1, req2, opt1=:opt1, opt2=:opt2, *splat)
  [req1, req2, opt1, opt2, splat]
end

ok(req_only(1,2) == [1,2], 'required args should be set')
ok(opt_only == [:opt1, :opt2], 'optional args should set defaults when no arg is given')
ok(opt_only(1) == [1, :opt2], 'optional args should set defaults when some args are given')
ok(opt_only(1, 2) == [1, 2], 'optional args should set no defaults when all args are given')
ok(splat_only(1,2,3) == [1,2,3], 'splat args should suck all remaining args into an array')
ok(req_and_opt(10,20) == [10, 20, :opt1, :opt2], 'optional args with required opts 1')
ok(req_and_opt(10,20,30) == [10, 20, 30, :opt2], 'optional args with required opts 2')
ok(req_and_opt(10,20,30,40) == [10, 20, 30, 40], 'optional args with required opts 3')
ok(req_opt_and_splat(10,20) == [10, 20, :opt1, :opt2, []], 'required optional and splat params 1')
ok(req_opt_and_splat(10,20,30,40) == [10, 20, 30, 40, []], 'required optional and splat params 2')
ok(req_opt_and_splat(10,20,30,40,50,60,70) == [10, 20, 30, 40, [50,60,70]], 'required optional and splat params 3')

begin
  req_only(1)
  fail('fewer than min args should raise ArgumentError to req_only')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 2)', 'ArgumentError message when too few args to req_only')
end

begin
  req_only(1,2,3)
  fail('more than max args should raise ArgumentError to req_only')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (3 for 2)', 'ArgumentError message when too many args to req_only')
end

begin
  req_and_opt(1)
  fail('fewer than min args should raise ArgumentError to req_and_opt')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 2)', 'ArgumentError message when too few args to req_and_opt')
end

begin
  req_and_opt(1,2,3,4,5,6)
  fail('more than max args should raise ArgumentError to req_and_opt')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (6 for 4)', 'ArgumentError message when too many args to req_and_opt')
end

begin
  req_opt_and_splat(1)
  fail('fewer than min args should raise ArgumentError to req_opt_and_splat')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 2)', 'ArgumentError message when too few args to req_opt_and_splat')
end

begin
  req_opt_and_splat(1,2,3,4,5,6,7,8,9,10,11,12,13,14)
  ok(true, 'no upper bound and number of args to req_opt_and_splat')
rescue ArgumentError => e
  fail('args with splat should not raise ArgumentError for too many params')
end

begin
  "foo".to_s(1)
  fail('calling a method defined in JS should check number of arguments')
rescue ArgumentError => e
  ok(e.message == 'wrong number of arguments (1 for 0)', 'methods implemented in JS should check number of arguments')
end

o = Object.new
begin
  o.stuff
  fail('unknown method should raise exception')
rescue NoMethodError => e
  ok(e.message.slice(0, 24)  == "undefined method 'stuff'", 'unknown method should raise NoMethodError')
end

#-------------------------------------------------------------------------------
# Modules and Classes
#-------------------------------------------------------------------------------

class Class1
  def bar
    'Class1#bar'
  end

  def baz
    'Class1#baz'
  end
end

ok(Class1.is_a?(Class) == true, 'class definitions should create an instance of Class')
ok(Class1.superclass == Object, 'class definitions without a superclass should have a superclass of Object')
ok(Class1.new.bar == 'Class1#bar', 'should be able to define classes with instance methods')
ok(Class1.instance_methods(false) == [:bar, :baz], 'class should know its instance methods')

ok((class Class2; 8; 9; end) == 9, 'class definitions should yield value of last expression of body')

class Class3 < Class1
  def baz
    'Class3#baz'
  end
end

ok(Class3.superclass == Class1, 'class definitions with a superclass')
ok(Class3.new.bar == 'Class1#bar', 'child classes can access methods implemented in the superclass')
ok(Class3.new.baz == 'Class3#baz', 'child classes can override methods implemented in the superclass')

