(function() {

#define ISEQ_STATUS_NORMAL 0
#define ISEQ_STATUS_RAISE  1
#define ISEQ_STATUS_RETRY  2
#define ISEQ_STATUS_RETURN 3

#define VM_DEBUG(sf, msg) Bully.platform.puts(sf.toString() +  ': ' + msg)

var StackFrame = function(iseq, opts) {
  this.iseq      = iseq;
  this.ip        = 0;
  this.sp        = 0;
  this.modules   = [];
  this.status    = ISEQ_STATUS_NORMAL;
  this.stack     = opts.stackSize ? new Array(opts.stackSize) : [];
  this.self      = opts.self || Bully.main;
  this.parent    = opts.parent || null;
  this.locals    = opts.locals || [];
  this.isDynamic = !!opts.isDynamic;

  return this;
};

StackFrame.prototype = {
  toString: function() {
    var name = this.iseq[ISEQ_NAME_IDX],
        type = this.iseq[ISEQ_TYPE_IDX],
        body = this.iseq[ISEQ_BODY_IDX];
    return 'StackFrame(name: ' + name + ', type: ' + type + ', ip: ' + this.ip + ', numinsns: ' + body.length + ', status: ' + this.status + ', sp: ' + this.sp + ', stack: ' + this.stack.toString() + ')';
  },

  push: function(obj) {
    this.stack[this.sp++] = obj;
    return this;
  },

  pop: function() {
    return this.stack[--this.sp];
  },

  peek: function() {
    return this.stack[this.sp - 1];
  },

  currentModule: function() {
    var len = this.modules.length;

    return len === 0 ? Bully.Object : this.modules[len - 1];
  }
};

Bully.VM = {
  frames: [],

  currentFrame: function() {
    return this.frames[this.frames.length - 1];
  },

  pushFrame: function(frame) {
    this.frames.push(frame);
    return this;
  },

  popFrame: function() {
    var i, sf = this.frames.pop();

    // check for uncaught exception
    if (!sf.parent && sf.status === ISEQ_STATUS_RAISE) {
      send(Bully.main, 'p', sf.pop());
      Bully.platform.exit(1);
    }

    // copy the current status and stack to the parent stack
    if (sf.parent) {
      sf.parent.status = sf.status;

      for (i = 0; i < sf.sp; i++) {
        sf.parent.push(sf.stack[i]);
      }
    }

    return sf;
  },

  // Runs a compiled Bully program.
  run: function(iseq) {
    this.frames = [];

    this.runISeq(iseq, [], { self: Bully.main });
  },

  runISeq: function(iseq, args, sfOpts) {
    var body  = iseq[ISEQ_BODY_IDX],
        len   = body.length,
        sf, startLabel, ins, recv, sendargs, mod, stackiseq, klass, i, localSF,
        ary;

    // process labels
    if (!iseq.labels) {
      iseq.labels = {};
      for (i = 0; i < len; i++) {
        ins = body[i];
        if (typeof ins === 'string') { iseq.labels[ins] = i; }
      }
    }

    sf = new StackFrame(iseq, sfOpts);
    sf.stackSize = iseq[ISEQ_MAX_STACK_IDX];
    this.pushFrame(sf);

    try { this.setupArguments(iseq, args, sf); }
    catch (e) {
      // exceptions raised in argument setup code need to exit the frame
      // immediately so that the calling frame can handle the exception
      if (e instanceof Bully.RaiseException) {
        sf.status = ISEQ_STATUS_RAISE;
        sf.push(e.exception);
        this.popFrame();
        return;
      } else { throw e; }
    }

    main_loop:
    for (; sf.ip < len; sf.ip++) {
      ins = body[sf.ip];

      if (typeof ins !== 'object') { continue; }

      try {
        switch (ins[0]) {
          case 'pop':
            sf.pop();
            break;
          case 'putnil':
            sf.push(null);
            break;
          case 'putself':
            sf.push(sf.self);
            break;
          case 'putbuiltin':
            sf.push(Bully[ins[1]]);
            break;
          case 'putcurrentmodule':
            sf.push(sf.currentModule());
            break;
          case 'putiseq':
            sf.push(ins[1]);
            break;
          case 'putobject':
            sf.push(ins[1]);
            break;
          case 'putstring':
            sf.push(Bully.String.make(ins[1]));
            break;
          case 'putsymbol':
            sf.push(ins[1]);
            break;
          case 'newarray':
            ary = new Array(ins[1]);
            for (i = ins[1] - 1; i >= 0; i--) { ary[i] = sf.pop(); }
            sf.push(Bully.Array.make(ary));
            break;
          case 'definemethod':
            stackiseq = sf.pop();
            mod       = sf.pop();
            Bully.define_method(mod, ins[1], stackiseq);
            break;
          case 'send':
            sendargs = [];
            for (i = 0; i < ins[2]; i += 1) { sendargs.unshift(sf.pop()); }
            recv = sf.pop();
            this.sendMethod(recv, ins[1], sendargs, sf);
            break;
          case 'setlocal':
            localSF = sf;
            while (localSF.isDynamic) { localSF = localSF.parent; }
            localSF.locals[ins[1]] = sf.pop();
            break;
          case 'getlocal':
            localSF = sf;
            while (localSF.isDynamic) { localSF = localSF.parent; }
            sf.push(localSF.locals[ins[1]]);
            break;
          case 'setdynamic':
            localSF = sf;
            for (i = 0; i < ins[2]; i++) { localSF = localSF.parent; }
            localSF.locals[ins[1]] = sf.pop();
            break;
          case 'getdynamic':
            localSF = sf;
            for (i = 0; i < ins[2]; i++) { localSF = localSF.parent; }
            sf.push(localSF.locals[ins[1]]);
            break;
          case 'getconstant':
            klass = sf.pop();
            sf.push(this.getConstant(klass, ins[1]));
            break;
          case 'branchif':
            if (Bully.test(sf.pop())) { sf.ip = iseq.labels[ins[1]]; }
            break;
          case 'branchunless':
            if (!Bully.test(sf.pop())) { sf.ip = iseq.labels[ins[1]]; }
            break;
          case 'jump':
            sf.ip = iseq.labels[ins[1]];
            break;
          case 'throw':
            this._throw(sf.pop(), ins[1]);
            break;
          case 'leave':
            break main_loop;
          default:
            throw new Error('unknown opcode: ' + ins[0]);
        }
      }
      catch (e) {
        if (e instanceof Bully.RaiseException) {
          sf.status = ISEQ_STATUS_RAISE;
          sf.push(e.exception);
        } else { throw e; }
      }

      // check to see if an exception was raised or bubbled up
      if (sf.status === ISEQ_STATUS_RAISE) {
        this.handleException();

        if (sf.status === ISEQ_STATUS_RAISE) {
          break main_loop;
        }
      }
      else if (sf.status === ISEQ_STATUS_RETRY) {
        break main_loop;
      }
    }

    this.popFrame();
  },

  setupArguments: function(iseq, args, sf) {
    var nargs  = args.length,
        desc   = iseq[ISEQ_ARGS_IDX],
        nreq   = desc[ISEQ_ARGS_NUM_REQ_IDX],
        nopt   = desc[ISEQ_ARGS_NUM_OPT_IDX],
        splat  = desc[ISEQ_ARGS_SPLAT_IDX],
        labels = desc[ISEQ_ARGS_LABELS_IDX],
        min    = nreq,
        max    = splat >= 0 ? -1 : nreq + nopt,
        msg    = 'wrong number of arguments (',
        i;

    if (min === max) {
      // 0 or more required arguments, no optionals
      if (nargs !== min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
    else if (max === -1) {
      // no limit on args
      if (nargs < min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
    else {
      // bounded number of args
      if (nargs < min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
      else if (nargs > max) {
        msg += nargs + ' for ' + max + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }

    // copy arguments to local variables
    for (i = 0; i < nargs; i++) {
      sf.locals[i] = args[i];
    }

    if (splat >= 0) {
      sf.locals[splat] = Bully.Array.make(args.slice(nreq + nopt));
    }

    if (nopt > 0) {
      sf.ip = nargs >= nreq + nopt ?
        sf.iseq.labels[labels[labels.length - 1]] :
        sf.iseq.labels[labels[nargs - nreq]];
    }
  },

  sendMethod: function(recv, name, args, sf) {
    var method = Bully.find_method(Bully.class_of(recv), name),
        status;

    // FIXME: make sure method is found

    if (typeof method === 'function') {
      sf.push(method.call(null, recv, args));
    }
    else {
      this.runISeq(method, args, { parent: sf, self: recv });
    }
  },

  getConstant: function(klass, name) {
    var modules;

    if (!klass) {
      // FIXME: perform lexical lookup
      return Bully.const_get(Bully.Object, name);
    }
    else {
      return Bully.const_get(klass, name);
    }
  },

  handleException: function() {
    var sf          = this.currentFrame(),
        rescueEntry = this._findCatchEntry('rescue', sf),
        ensureEntry = this._findCatchEntry('ensure', sf),
        retryEntry  = this._findCatchEntry('retry', sf),
        ex;

    if (!rescueEntry && !ensureEntry) { return; }

    ex = sf.pop();

    if (rescueEntry) {
      sf.sp = rescueEntry[CATCH_ENTRY_SP_IDX];
      this.runISeq(rescueEntry[CATCH_ENTRY_ISEQ_IDX], [],
        { parent: sf, self: sf.self, isDynamic: true, locals: [ex] });

      if (sf.status === ISEQ_STATUS_NORMAL) {
        // the exception was rescued, so set the instuction pointer to the
        // entry's continue label and continue executing the current frame
        sf.ip = sf.iseq.labels[rescueEntry[CATCH_ENTRY_CONT_LBL_IDX]];
        return;
      }
      else if (sf.status === ISEQ_STATUS_RETRY) {
        sf.sp = retryEntry[CATCH_ENTRY_SP_IDX];
        sf.ip = sf.iseq.labels[retryEntry[CATCH_ENTRY_CONT_LBL_IDX]];
        sf.status = ISEQ_STATUS_NORMAL;
        return;
      }
      else if (ensureEntry) {
        // the exception has not been handled yet, but its possible its been
        // replaced by another raise within the rescue block, so we need to
        // get the new exception object to give to the ensure block
        ex = sf.pop();
      }
    }

    // the exception hasn't been rescued yet, so run the matching ensure entry
    // if it exists and let the exception bubble up
    if (ensureEntry) {
      sf.sp = ensureEntry[CATCH_ENTRY_SP_IDX];
      this.runISeq(ensureEntry[CATCH_ENTRY_ISEQ_IDX], [],
        { parent: sf, self: sf.self, isDynamic: true, locals: [ex] });
      sf.ip = sf.iseq.labels[ensureEntry[CATCH_ENTRY_CONT_LBL_IDX]];
    }
  },

  _findCatchEntry: function(type, sf) {
    var catchTbl = sf.iseq[ISEQ_CATCH_TBL_IDX], len = catchTbl.length,
        entry, entryType, start, stop, i;

    for (i = 0; i < len; i++) {
      entry     = catchTbl[i];
      entryType = entry[CATCH_ENTRY_TYPE_IDX];
      start     = sf.iseq.labels[entry[CATCH_ENTRY_START_LBL_IDX]];
      stop      = sf.iseq.labels[entry[CATCH_ENTRY_STOP_LBL_IDX]];

      if (entryType === type && start <= sf.ip + 1 && sf.ip + 1 <= stop) {
        return entry;
      }
    }

    return null;
  },

  _throw: function(obj, throwType) {
    var sf = this.currentFrame();

    switch (throwType) {
      case VM_THROW_TYPE_RAISE:
        sf.status = ISEQ_STATUS_RAISE;
        sf.push(obj);
        return;
      case VM_THROW_TYPE_RETRY:
        sf.status = ISEQ_STATUS_RETRY;
        return;
      default:
        throw new Error('invalid throw type: ' + throwType);
    }
  }
};

}());

