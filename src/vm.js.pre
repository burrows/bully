(function() {

#define SF_STATUS_NORMAL 0
#define SF_STATUS_RAISE  1
#define SF_STATUS_RETRY  2
#define SF_STATUS_RETURN 3

#define VM_DEBUG(sf, msg) Bully.platform.puts(sf.toString() +  ': ' + msg)

var extend, StackFrame, BullyStackFrame, JSStackFrame;

extend = function(child, parent) {
  var prop, childProto = child.prototype, parentProto = parent.prototype;
  for (prop in parentProto) {
    if (!parentProto.hasOwnProperty(prop)) { continue; }
    childProto[prop] = parentProto[prop];
  }
};

StackFrame = function(type, name, opts) {
  this.type      = type;
  this.name      = name;
  this.stack     = new Array(opts.stackSize || 1);
  this.sp        = 0;
  this.status    = SF_STATUS_NORMAL;
  this.parent    = opts.parent || null;
  this.args      = opts.args || [];
  this.proc      = opts.proc || null; 
  this.self      = 'self' in opts ? opts.self : Bully.main;
  this.cbase     = opts.cbase || Bully.real_class_of(this.self);
  this.isDynamic = type === 'block' || type === 'rescue' || type === 'ensure';
};

StackFrame.prototype.dumpStack = function() {
  var sp = this.sp, items = [], stackitem, i;

  for (i = 0; i < sp; i++) {
    stackitem = this.stack[i];
    items.push(stackitem === null ? 'null' : stackitem.toString());
  }

  return '[' + items.join(', ') + ']';
};

StackFrame.prototype.toString = function() {
  return 'StackFrame(type: ' + this.type + ', name: ' + this.name + ', status: ' + this.status + ', sp: ' + this.sp + ', stack: ' + this.dumpStack() + ')';
};

StackFrame.prototype.push = function(obj) {
  this.stack[this.sp++] = obj;
  return this;
};

StackFrame.prototype.pop = function() {
  if (this.sp === 0) { throw new Error('stack is too small for pop!'); }
  return this.stack[--this.sp];
};

StackFrame.prototype.peek = function() {
  return this.stack[this.sp - 1];
};

BullyStackFrame = function(iseq, opts) {
  opts.stackSize = iseq[ISEQ_MAX_STACK_IDX];

  StackFrame.call(this, iseq[ISEQ_TYPE_IDX], iseq[ISEQ_NAME_IDX], opts);

  this.code       = iseq;
  this.ip         = 0;
  this.locals     = opts.locals || [];
  this.catchTable = iseq[ISEQ_CATCH_TBL_IDX];

  return this;
};

extend(BullyStackFrame, StackFrame);

JSStackFrame = function(fn, opts) {
  StackFrame.call(this, 'method', fn.method_name, opts);

  this.code = fn;

  return this;
};

extend(JSStackFrame, StackFrame);

Bully.VM = {
  init: function() {
    this.frames = [];
    this.exitStatus = 0;
    this.uncaughtException = null;
    this.currentFrame = null;
  },

  // Runs a compiled Bully program.
  run: function(iseq) {
    this.frames = [];

    this.runISeq(iseq, { self: Bully.main });

    if (this.uncaughtException) {
      send(Bully.main, 'p', this.uncaughtException);
    }

    Bully.platform.exit(this.exitStatus);
  },

  currentMethodFrame: function() {
    var sf = this.currentFrame;
    
    while (sf && sf.type !== 'method') { sf = sf.parentFrame; }
    
    return sf;
  },

  pushFrame: function(frame) {
    this.frames.push(frame);
    this.currentFrame = frame;
    return this;
  },

  popFrame: function() {
    var sf = this.frames.pop(), ret = null, parentType, type;

    this.currentFrame = this.frames[this.frames.length - 1];

    // check for uncaught exception
    if (!sf.parent && sf.status === SF_STATUS_RAISE) {
      //send(Bully.main, 'p', sf.pop());
      //Bully.platform.exit(1);
      this.uncaughtException = sf.pop();
      this.exitStatus = 1;
      return;
    }

    // DEBUG
    switch (sf.status) {
      case SF_STATUS_NORMAL:
        if (sf.sp !== 1) {
          throw new Error('popping frame with status ' + sf.status + ' with stack size of: ' + sf.sp + ' (should be 1)');
        }
        break;
      case SF_STATUS_RETRY:
        if (sf.sp !== 0) {
          throw new Error('popping frame with status ' + sf.status + ' with stack size of: ' + sf.sp + ' (should be 0)');
        }
        break;
      case SF_STATUS_RAISE:
        break;
      default:
        throw new Error('invalid ISeq status: ' + sf.status);
    }

    if (!sf.parent) { return sf.pop(); }

    sf.parent.status = sf.status;

    parentType = sf.parent instanceof BullyStackFrame ? 'bully' : 'js';
    type       = sf        instanceof BullyStackFrame ? 'bully' : 'js';

    switch (parentType + '-' + type) {
      case 'bully-bully':
        if (sf.status === SF_STATUS_NORMAL) {
          ret = sf.pop();
          sf.parent.push(ret);
        }
        else if (sf.status === SF_STATUS_RAISE) {
          sf.parent.push(sf.pop());
        }
        break;
      case 'bully-js':
        if (sf.status === SF_STATUS_NORMAL) {
          ret = sf.pop();
          sf.parent.push(ret);
        }
        else if (sf.status === SF_STATUS_RAISE) {
          sf.parent.push(sf.pop());
        }
        break;
      case 'js-bully':
        if (sf.status === SF_STATUS_NORMAL) {
          ret = sf.pop();
        }
        else if (sf.status === SF_STATUS_RAISE) {
          throw sf.pop();
        }
        break;
      case 'js-js':
        if (sf.status === SF_STATUS_NORMAL) {
          ret = sf.pop();
        }
        else if (sf.status === SF_STATUS_RAISE) {
          throw sf.pop();
        }
        break;
    }

    return ret;
  },

  runJSFunc: function(fn, sfOpts) {
    var sf = new JSStackFrame(fn, sfOpts), e;

    this.pushFrame(sf);

    try {
      this.checkArgumentCount(fn.min_args, fn.max_args, sf.args.length);
      sf.push(fn.call(null, sf.self, sf.args, sf.proc));
    }
    catch (e) {
      if (!(e instanceof Bully.RaiseException)) { throw e; }

      sf.status = SF_STATUS_RAISE;
      sf.push(e.exception);
    }

    return this.popFrame();
  },

  runISeq: function(iseq, sfOpts) {
    var body  = iseq[ISEQ_BODY_IDX],
        len   = body.length,
        sf, startLabel, ins, recv, sendargs, mod, klass, i, localSF, _super,
        ary, localvar, hasArgs;

    // process labels
    if (!iseq.labels) {
      iseq.labels = {};
      for (i = 0; i < len; i++) {
        ins = body[i];
        if (typeof ins === 'string') { iseq.labels[ins] = i; }
      }
    }

    sf = new BullyStackFrame(iseq, sfOpts);
    this.pushFrame(sf);

    try { this.setupISeqArgs(sf); }
    catch (e1) {
      // exceptions raised in argument setup code need to exit the frame
      // immediately so that the calling frame can handle the exception
      if (e1 instanceof Bully.RaiseException) {
        sf.status = SF_STATUS_RAISE;
        sf.push(e1.exception);
        return this.popFrame();
      } else { throw e1; }
    }

    main_loop:
    for (; sf.ip < len; sf.ip++) {
      ins = body[sf.ip];

      if (typeof ins !== 'object') { continue; }

      try {
        switch (ins[0]) {
          case 'pop':
            sf.pop();
            break;
          case 'dup':
            sf.push(sf.peek());
            break;
          case 'setn':
            sf.stack[sf.sp - 1 - ins[1]] = sf.stack[sf.sp - 1];
            break;
          case 'putnil':
            sf.push(null);
            break;
          case 'putself':
            sf.push(sf.self);
            break;
          case 'putbuiltin':
            sf.push(Bully[ins[1]]);
            break;
          case 'putcbase':
            sf.push(sf.cbase);
            break;
          case 'putiseq':
            sf.push(ins[1]);
            break;
          case 'putobject':
            sf.push(ins[1]);
            break;
          case 'putstring':
            sf.push(Bully.String.make(ins[1]));
            break;
          case 'putsymbol':
            sf.push(ins[1]);
            break;
          case 'newarray':
            ary = new Array(ins[1]);
            for (i = ins[1] - 1; i >= 0; i--) { ary[i] = sf.pop(); }
            sf.push(Bully.Array.make(ary));
            break;
          case 'defineclass':
            _super = sf.pop();
            mod    = sf.pop();
            switch (ins[3]) {
              case VM_DEFINECLASS_TYPE_CLASS:
                klass = Bully.define_class_under(mod, ins[1], _super);
                this.runISeq(ins[2], { parent: sf, self: klass, cbase: klass });
                break;
              case VM_DEFINECLASS_TYPE_SINGLETON_CLASS:
                klass = Bully.singleton_class(mod);
                this.runISeq(ins[2], { parent: sf, self: klass, cbase: klass });
                break;
              case VM_DEFINECLASS_TYPE_MODULE:
                klass = Bully.define_module_under(mod, ins[1]);
                this.runISeq(ins[2], { parent: sf, self: klass, cbase: klass });
                break;
              default: throw new Error('invalid defineclass type: ' + ins[3]);
            }
            break;
          case 'definemethod':
            mod = sf.pop();
            if (ins[3]) {
              // singleton method
              Bully.define_singleton_method(mod, ins[1], ins[2]);
            }
            else {
              // instance method
              Bully.define_method(mod, ins[1], ins[2]);
            }
            break;
          case 'send':
            sendargs = [];
            for (i = 0; i < ins[2]; i++) { sendargs.unshift(sf.pop()); }
            recv = sf.pop();
            this.sendMethod(recv, ins[1], sendargs, null);
            break;
          case 'invokesuper':
            sendargs = [];
            for (i = 0; i < ins[1]; i++) { sendargs.unshift(sf.pop()); }
            if (!sf.pop()) { sendargs = null; }
            this.invokeSuper(sendargs, null);
            break;
          case 'setlocal':
            localSF = sf;
            while (localSF.isDynamic) { localSF = localSF.parent; }
            localSF.locals[ins[1]] = sf.pop();
            break;
          case 'getlocal':
            localSF = sf;
            while (localSF.isDynamic) { localSF = localSF.parent; }
            localvar = localSF.locals[ins[1]];
            sf.push(localvar === undefined ? null : localvar);
            break;
          case 'setinstancevariable':
            Bully.ivar_set(sf.self, ins[1], sf.pop());
            break;
          case 'getinstancevariable':
            sf.push(Bully.ivar_get(sf.self, ins[1]));
            break;
          case 'setdynamic':
            localSF = sf;
            for (i = 0; i < ins[2]; i++) { localSF = localSF.parent; }
            localSF.locals[ins[1]] = sf.pop();
            break;
          case 'getdynamic':
            localSF = sf;
            for (i = 0; i < ins[2]; i++) { localSF = localSF.parent; }
            sf.push(localSF.locals[ins[1]]);
            break;
          case 'getconstant':
            mod = sf.pop();
            this.getConstant(mod, ins[1], sf);
            break;
          case 'setconstant':
            mod = sf.pop();
            Bully.const_set(mod, ins[1], sf.pop());
            break;
          case 'branchif':
            if (Bully.test(sf.pop())) { sf.ip = iseq.labels[ins[1]]; }
            break;
          case 'branchunless':
            if (!Bully.test(sf.pop())) { sf.ip = iseq.labels[ins[1]]; }
            break;
          case 'jump':
            sf.ip = iseq.labels[ins[1]];
            break;
          case 'throw':
            this._throw(sf.pop(), ins[1]);
            break;
          case 'leave':
            break main_loop;
          default:
            throw new Error('unknown opcode: ' + ins[0]);
        }
      }
      catch (e2) {
        if (!(e2 instanceof Bully.RaiseException)) { throw e2; }

        sf.status = SF_STATUS_RAISE;
        sf.push(e2.exception);
      }

      // check to see if an exception was raised or bubbled up
      if (sf.status === SF_STATUS_RAISE) {
        this.handleException();

        if (sf.status === SF_STATUS_RAISE) {
          break main_loop;
        }
      }
      else if (sf.status === SF_STATUS_RETRY) {
        break main_loop;
      }
    }

    return this.popFrame();
  },

  // Private: Checks that the number of arguments passed to a method are acceptable.
  //
  // Bully methods can accept a fixed number of arguments, optional arguments, and
  // splat arguments.  When methods are defined, their minimum and maximum number
  // of arguments are calculated from the method signature.  Those values are used
  // here to check whether the number of arguments passed is acceptable.  If an
  // incorrect number of arguments are passed, then an ArgumentError exception is
  // raised.
  //
  // min   - The minimum number of arguments the method accepts.
  // max   - The maximum number of arguments the method accepts.
  // nargs - The number of arguments passed to the method.
  //
  // Returns nothing.
  // Raises ArgumentError if an incorrect number of arguments are passed.
  checkArgumentCount: function(min, max, nargs) {
    var msg = 'wrong number of arguments (';

    if (min === max) {
      // 0 or more required arguments, no optionals
      if (nargs !== min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
    else if (max === -1) {
      // no limit on args
      if (nargs < min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
    else {
      // bounded number of args
      if (nargs < min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
      else if (nargs > max) {
        msg += nargs + ' for ' + max + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
  },

  setupISeqArgs: function(sf) {
    var iseq   = sf.code,
        args   = sf.args,
        nargs  = args.length,
        desc   = iseq[ISEQ_ARGS_IDX],
        nreq   = desc[ISEQ_ARGS_NUM_REQ_IDX],
        nopt   = desc[ISEQ_ARGS_NUM_OPT_IDX],
        splat  = desc[ISEQ_ARGS_SPLAT_IDX],
        labels = desc[ISEQ_ARGS_LABELS_IDX],
        min    = nreq,
        max    = splat >= 0 ? -1 : nreq + nopt,
        i;

    this.checkArgumentCount(min, max, nargs);

    // copy arguments to local variables
    for (i = 0; i < nargs; i++) { sf.locals[i] = args[i]; }

    if (splat >= 0) {
      sf.locals[splat] = Bully.Array.make(args.slice(nreq + nopt));
    }

    if (nopt > 0) {
      sf.ip = nargs >= nreq + nopt ?
        iseq.labels[labels[labels.length - 1]] :
        iseq.labels[labels[nargs - nreq]];
    }
  },

  // Looks up and invokes a method on the given receiver object.  If the method
  // cannot be found anywhere in the object's inheritance chain, the method
  // 'method_missing' will be sent to the object instead.
  //
  // If sendMethod is called in the context of a stack frame (via the 'send'
  // instruction) then it will place the return value of the method onto the
  // stack.  If sendMethod is called outside the context of a stack frame (e.g.
  // a method implemented in javascript calls it) then the return value of
  // them method is simply returned.
  //
  // Method dispatch is very straightforward, we simply start with the given
  // object's class and check to see if the method is defined in its m_tbl
  // property.  If the method is not found, we simply traverse the superclass
  // chain until it can be located.  If the method is not found, the process
  // starts over again to look for the 'method_missing' method.
  //
  // recv  - The object to invoke the method on.
  // name  - The name of the method to invoke.
  // args  - A javascript array containing the arguments to send (optional).
  // block - FIXME (optional).
  //
  // Returns the return value of the method.
  sendMethod: function(recv, name, args, block) {
    var method = Bully.find_method(Bully.class_of(recv), name), sfOpts;

    args = args || [];

    if (!method) {
      args.unshift(name);
      return this.sendMethod(recv, 'method_missing', args, block);
    }

    sfOpts = {
      parent: this.currentFrame,
      self: recv,
      cbase: Bully.is_a(recv, Bully.Module) ? recv : Bully.class_of(recv),
      args: args
    };

    return this[typeof method === 'function' ? 'runJSFunc' : 'runISeq'](method, sfOpts);
  },

  invokeSuper: function(args, block) {
    var sf          = this.currentFrame,
        methodFrame = this.currentMethodFrame(),
        klass       = methodFrame.code.klass,
        method      = Bully.find_method(klass._super, methodFrame.name),
        sfOpts;

    if (!method) {
      Bully.raise(Bully.NoMethodError, "super: no superclass method '" + methodFrame.name + "' for " + send(sf.self, 'inspect').data);
    }

    sfOpts = { parent: sf, self: sf.self, cbase: sf.cbase, args: args || sf.args };
    return this[typeof method === 'function' ? 'runJSFunc' : 'runISeq'](method, sfOpts);
  },

  getConstant: function(mod, name, sf) {
    var tmpsf = sf;

    if (mod) { sf.push(Bully.const_get(mod, name)); return; }

    // need to perform a lexical lookup
    do {
      if (Bully.const_defined(tmpsf.cbase, name, false)) {
        sf.push(Bully.const_get(tmpsf.cbase, name));
        return;
      }

      tmpsf = tmpsf.parent;
    } while (tmpsf);

    this.sendMethod(sf.cbase, 'const_missing', [name], null);
  },

  handleException: function() {
    var sf          = this.currentFrame,
        iseq        = sf.code,
        rescueEntry = this._findCatchEntry('rescue', sf),
        ensureEntry = this._findCatchEntry('ensure', sf),
        retryEntry, ex;

    if (!rescueEntry && !ensureEntry) { return; }

    ex = sf.pop();

    if (rescueEntry) {
      sf.sp = rescueEntry[CATCH_ENTRY_SP_IDX];
      sf.ip = iseq.labels[rescueEntry[CATCH_ENTRY_CONT_LBL_IDX]];
      this.runISeq(rescueEntry[CATCH_ENTRY_ISEQ_IDX],
        { parent: sf, self: sf.self, cbase: sf.cbase, locals: [ex] });

      if (sf.status === SF_STATUS_NORMAL) {
        // the exception was rescued, so continue executing the current frame
        return;
      }
      else if (sf.status === SF_STATUS_RETRY) {
        retryEntry = this._findCatchEntry('retry', sf);
        sf.sp = retryEntry[CATCH_ENTRY_SP_IDX];
        sf.ip = iseq.labels[retryEntry[CATCH_ENTRY_CONT_LBL_IDX]];
        sf.status = SF_STATUS_NORMAL;
        return;
      }
      else if (ensureEntry) {
        // the exception has not been handled yet, but its possible its been
        // replaced by another raise within the rescue block, so we need to
        // get the new exception object to give to the ensure block
        ex = sf.pop();
      }
    }

    // the exception hasn't been rescued yet, so run the matching ensure entry
    // if it exists and let the exception bubble up
    if (ensureEntry) {
      sf.sp = ensureEntry[CATCH_ENTRY_SP_IDX];
      sf.ip = iseq.labels[ensureEntry[CATCH_ENTRY_CONT_LBL_IDX]];
      this.runISeq(ensureEntry[CATCH_ENTRY_ISEQ_IDX],
        { parent: sf, self: sf.self, cbase: sf.cbase, locals: [ex] });
    }
  },

  _findCatchEntry: function(type, sf) {
    var catchTable = sf.catchTable,
        len        = catchTable.length,
        labels     = sf.code.labels,
        entry, entryType, start, stop, i;

    for (i = 0; i < len; i++) {
      entry     = catchTable[i];
      entryType = entry[CATCH_ENTRY_TYPE_IDX];
      start     = labels[entry[CATCH_ENTRY_START_LBL_IDX]];
      stop      = labels[entry[CATCH_ENTRY_STOP_LBL_IDX]];

      if (entryType === type && start <= sf.ip && sf.ip <= stop) {
        return entry;
      }
    }

    return null;
  },

  _throw: function(obj, throwType) {
    var sf = this.currentFrame;

    switch (throwType) {
      case VM_THROW_TYPE_RAISE:
        sf.status = SF_STATUS_RAISE;
        sf.push(obj);
        return;
      case VM_THROW_TYPE_RETRY:
        sf.status = SF_STATUS_RETRY;
        return;
      default:
        throw new Error('invalid throw type: ' + throwType);
    }
  }
};

}());

