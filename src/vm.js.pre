(function() {

var StackFrame = function(opts) {
  this.ip        = 0;
  this.sp        = 0;
  this.iseq      = opts.iseq || null;
  this.stack     = opts.stackSize ? new Array(opts.stackSize) : [];
  this.self      = opts.self || Bully.main;
  this.modules   = [];
  this.parent    = opts.parent || null;
  this.locals    = opts.locals || [];
  this.isDynamic = 'isDynamic' in opts ? opts.isDynamic : false;

  return this;
};

StackFrame.prototype = {
  toString: function() {
    var a = [], obj, i;

    for (i = 0; i < this.sp; i++) {
      obj = this.stack[i];
      if (obj === null) {
        a.push('nil');
      }
      else {
        a.push(obj.toString());
      }
    }

    return a.toString();
  },

  push: function(obj) {
    this.stack[this.sp++] = obj;
    return this;
  },

  pop: function() {
    return this.stack[--this.sp];
  },

  currentModule: function() {
    var len = this.modules.length;

    return len === 0 ? Bully.Object : this.modules[len - 1];
  }
};

#define VM_STATE_NORMAL 0
#define VM_STATE_RAISE  1

Bully.VM = {
  frames: [],

  state: VM_STATE_NORMAL,

  currentFrame: function() {
    return this.frames[this.frames.length - 1];
  },

  pushFrame: function(frame) {
    this.frames.push(frame);
    return this;
  },

  popFrame: function() {
    return this.frames.pop();
  },

  // Runs a compiled Bully program.
  run: function(iseq) {
    this.frames = [];
    this.state  = VM_STATE_NORMAL;

    return this.runISeq(iseq, [], { self: Bully.main });
  },

  runISeq: function(iseq, args, sfOpts) {
    var body = iseq[ISEQ_BODY_IDX], len = body.length,
        sf, startLabel, ins, recv, sendargs, mod, stackiseq, klass, i, localSF,
        ex;

    // process labels
    if (!iseq.labels) {
      iseq.labels = {};
      for (i = 0; i < len; i++) {
        ins = body[i];
        if (typeof ins === 'string') { iseq.labels[ins] = i; }
      }
    }

    sfOpts.stackSize = iseq[ISEQ_MAX_STACK_IDX];
    sfOpts.iseq      = iseq;

    sf = new StackFrame(sfOpts);
    this.pushFrame(sf);

    if ((startLabel = this.setupArguments(iseq, args, sf))) {
      sf.ip = iseq.labels[startLabel];
    }

    main_loop:
    for (; sf.ip < len; sf.ip++) {
      ins = body[sf.ip];

      if (typeof ins !== 'object') { continue; }

      switch (ins[0]) {
        case 'pop':
          sf.pop();
          break;
        case 'putnil':
          sf.push(null);
          break;
        case 'putself':
          sf.push(sf.self);
          break;
        case 'putbuiltin':
          sf.push(Bully[ins[1]]);
          break;
        case 'putcurrentmodule':
          sf.push(sf.currentModule());
          break;
        case 'putiseq':
          sf.push(ins[1]);
          break;
        case 'putobject':
          sf.push(ins[1]);
          break;
        case 'putstring':
          sf.push(Bully.String.make(ins[1]));
          break;
        case 'definemethod':
          stackiseq = sf.pop();
          mod       = sf.pop();
          Bully.define_method(mod, ins[1], stackiseq);
          break;
        case 'send':
          sendargs = [];
          for (i = 0; i < ins[2]; i += 1) { sendargs.unshift(sf.pop()); }
          recv = sf.pop();
          this.sendMethod(recv, ins[1], sendargs, sf);
          break;
        case 'setlocal':
          localSF = sf;
          while (localSF.isDynamic) { localSF = localSF.parent; }
          localSF.locals[ins[1]] = sf.pop();
          break;
        case 'getlocal':
          localSF = sf;
          while (localSF.isDynamic) { localSF = localSF.parent; }
          sf.push(localSF.locals[ins[1]]);
          break;
        case 'setdynamic':
          localSF = sf;
          for (i = 0; i < ins[2]; i++) { localSF = localSF.parent; }
          localSF.locals[ins[1]] = sf.pop();
          break;
        case 'getdynamic':
          localSF = sf;
          for (i = 0; i < ins[2]; i++) { localSF = localSF.parent; }
          sf.push(localSF.locals[ins[1]]);
          break;
        case 'getconstant':
          klass = sf.pop();
          sf.push(this.getConstant(klass, ins[1]));
          break;
        case 'branchif':
          if (Bully.test(sf.pop())) { sf.ip = iseq.labels[ins[1]]; }
          break;
        case 'branchunless':
          if (!Bully.test(sf.pop())) { sf.ip = iseq.labels[ins[1]]; }
          break;
        case 'jump':
          sf.ip = iseq.labels[ins[1]];
          break;
        case 'throw':
          ex = sf.pop(); // FIXME: why is ex object pushed onto stack?
          this.state = VM_STATE_RAISE;
          break;
        case 'leave':
          break main_loop;
        default:
          throw new Error('unknown opcode: ' + ins[0]);
      }
    }

    // copy the current stack to the parent stack
    if (sf.parent) {
      for (i = 0; i < sf.sp; i++) { sf.parent.push(sf.stack[i]); }
    }

    this.popFrame();
  },

  setupArguments: function(iseq, args, sf) {
    var nargs  = args.length,
        desc   = iseq[ISEQ_ARGS_IDX],
        nreq   = desc[ISEQ_ARGS_NUM_REQ_IDX],
        nopt   = desc[ISEQ_ARGS_NUM_OPT_IDX],
        splat  = desc[ISEQ_ARGS_SPLAT_IDX],
        labels = desc[ISEQ_ARGS_LABELS_IDX],
        start  = null,
        i;

    // FIXME: check number of arguments passed

    // copy arguments to local variables
    for (i = 0; i < nargs; i++) {
      sf.locals[i] = args[i];
    }

    if (splat >= 0) {
      sf.locals[splat] = Bully.Array.make(args.slice(nreq + nopt));
    }

    if (nopt > 0) {
      return nargs >= nreq + nopt ? labels[labels.length - 1] :
        labels[nargs - nreq];
    }

    return null;
  },

  sendMethod: function(recv, name, args, sf) {
    var method = Bully.find_method(Bully.class_of(recv), name);

    // FIXME: make sure method is found

    if (typeof method === 'function') {
      sf.push(method.call(null, recv, args));
    }
    else {
      this.runISeq(method, args, { parent: sf, self: recv });
    }
  },

  getConstant: function(klass, name) {
    var modules;

    if (!klass) {
      // FIXME: perform lexical lookup
      return Bully.const_get(Bully.Object, name);
    }
    else {
      return Bully.const_get(klass, name);
    }
  },

  raise: function(ex) {
    var sf = this.currentFrame(),
        catchTbl, catchLen, type, start, stop, cont, catchEntry, i;

    do {
      catchTbl = sf.iseq[ISEQ_CATCH_TBL_IDX];
      catchLen = catchTbl.length;

      this.state = VM_STATE_NORMAL;

      for (i = 0; i < catchLen; i++) {
        catchEntry = catchTbl[i];
        type       = catchEntry[CATCH_ENTRY_TYPE_IDX];
        start      = sf.iseq.labels[catchEntry[CATCH_ENTRY_START_LBL_IDX]];
        stop       = sf.iseq.labels[catchEntry[CATCH_ENTRY_STOP_LBL_IDX]];
        cont       = sf.iseq.labels[catchEntry[CATCH_ENTRY_CONT_LBL_IDX]];

        if (!(start <= sf.ip && sf.ip <= stop)) { continue; }

        if (type === 'rescue' || type === 'ensure') {
          sf.sp = catchEntry[CATCH_ENTRY_SP_IDX];
          this.runISeq(catchEntry[CATCH_ENTRY_ISEQ_IDX], [],
                       { parent: sf, self: sf.self, isDynamic: true, locals: [ex] });

          if (this.state !== VM_STATE_RAISE) {
            // exception was handled, so return and continue executing this iseq
            sf.ip = cont;
            return;
          }
        }
      }

      this.popFrame();
    } while ((sf = this.currentFrame()))

    // no rescue handler was found, so abort program
    send(Bully.main, 'p', ex);
    Bully.platform.exit(1);
  }
};

}());

