(function() {

#define SF_STATUS_NORMAL 0
#define SF_STATUS_RAISE  1
#define SF_STATUS_RETRY  2
#define SF_STATUS_RETURN 3

#define VM_DEBUG(sf, msg) Bully.platform.puts(sf.toString() +  ': ' + msg)

var extend, StackFrame, MethodFrame, ClassFrame, BlockFrame;

extend = function(child, parent) {
  var prop, childProto = child.prototype, parentProto = parent.prototype;
  for (prop in parentProto) {
    if (!parentProto.hasOwnProperty(prop)) { continue; }
    childProto[prop] = parentProto[prop];
  }
};

StackFrame = function StackFrame(type, name, code, prevFrame, self, args, locals, stackSize) {
  this.type      = type;
  this.name      = name;
  this.code      = code;
  this.isJS      = typeof code === 'function';
  this.isISeq    = !this.isJS;
  this.prevFrame = prevFrame;
  this.self      = self;
  this.args      = args;
  this.locals    = locals;
  this.status    = SF_STATUS_NORMAL;
  this.stack     = new Array(stackSize);
  this.ip        = 0;
  this.sp        = 0;

  return this;
};

StackFrame.prototype.push = function(obj) {
  this.stack[this.sp++] = obj;
  return this;
};

StackFrame.prototype.pop = function() {
  if (this.sp === 0) { throw new Error('stack is too small for pop!'); }
  return this.stack[--this.sp];
};

StackFrame.prototype.peek = function() {
  return this.stack[this.sp - 1];
};

StackFrame.prototype.dumpStack = function() {
  var sp = this.sp, items = [], item, i;

  for (i = 0; i < sp; i++) {
    item = this.stack[i];
    if (typeof item === 'undefined') { items.push('undefined'); }
    else if (item === null) { items.push('null'); }
    else { items.push(item.toString()); }
  }

  return '[' + items.join(', ') + ']';
};

StackFrame.prototype.toString = function() {
  return this.constructor.name + '(type: ' + this.type + ', name: ' + this.name + ', status: ' + this.status + ', sp: ' + this.sp + ', stack: ' + this.dumpStack() + ')';
};

MethodFrame = function MethodFrame(code, prevFrame, self, args, proc) {
  var type, name, stackSize;

  if (typeof code === 'function') {
    type      = 'jsmethod';
    name      = code.methodName;
    stackSize = 0;
  }
  else {
    type      = code[ISEQ_TYPE_IDX];
    name      = code[ISEQ_NAME_IDX];
    stackSize = code[ISEQ_MAX_STACK_IDX];
  }

  StackFrame.call(this, type, name, code, prevFrame, self, args, [], stackSize);

  this.proc = proc;

  return this;
};

extend(MethodFrame, StackFrame);

ClassFrame = function ClassFrame(iseq, prevFrame, self) {
  var type      = iseq[ISEQ_TYPE_IDX],
      name      = iseq[ISEQ_NAME_IDX],
      stackSize = iseq[ISEQ_MAX_STACK_IDX];

  StackFrame.call(this, type, name, iseq, prevFrame, self, [], [], stackSize);

  return this;
};

extend(ClassFrame, StackFrame);

BlockFrame = function BlockFrame(code, prevFrame, localFrame, self, args, locals) {
  var type, name, stackSize;

  if (typeof code === 'function') {
    type      = 'function';
    name      = 'block';
    stackSize = 0;
  }
  else {
    type      = code[ISEQ_TYPE_IDX];
    name      = code[ISEQ_NAME_IDX];
    stackSize = code[ISEQ_MAX_STACK_IDX];
  }

  StackFrame.call(this, type, name, code, prevFrame, self, args, locals, stackSize);

  this.localFrame = localFrame;
  this.isLambda   = code.isLambda;

  return this;
};

extend(BlockFrame, StackFrame);

Bully.VM = {
  frames: [],
  currentException: null,
  currentFrame: null,
  lexicalModules: [],

  init: function() {},

  // Runs a compiled Bully program.
  run: function(iseq) {
    this.runMethodFrame(new MethodFrame(iseq, null, Bully.main, [], null));

    if (this.currentException) {
      send(Bully.main, 'p', this.currentException);
      Bully.platform.exit(1);
    }

    Bully.platform.exit(0);
  },

  currentMethodFrame: function() {
    var frame = this.currentFrame;
    while (frame && !(frame instanceof MethodFrame)) {
      frame = (frame instanceof BlockFrame) ? frame.localFrame : frame.prevFrame;
    }
    return frame;
  },

  pushModule: function(mod) {
    this.lexicalModules.push(mod);
    return mod;
  },

  popModule: function() {
    return this.lexicalModules.pop();
  },

  cbase: function() {
    var mods = this.lexicalModules, len = mods.length;
    return len > 0 ? mods[len - 1] : Bully.Object;
  },

  pushFrame: function(frame) {
    this.frames.push(frame);
    this.currentFrame = frame;
    return this;
  },

  popFrame: function() {
    var frame = this.frames.pop();
    this.currentFrame = this.frames[this.frames.length - 1];
    return frame;
  },

  _setupMethodArgs: function(frame) {
    var iseq, args, nargs, desc, nreq, nopt, splat, labels, min, max, i;

    if (frame.isJS) {
      this._checkArgumentCount(frame.code.min_args, frame.code.max_args,
        frame.args.length);
    }
    else {
      iseq   = frame.code;
      args   = frame.args;
      nargs  = args.length;
      desc   = iseq[ISEQ_ARGS_IDX];
      nreq   = desc[ISEQ_ARGS_NUM_REQ_IDX];
      nopt   = desc[ISEQ_ARGS_NUM_OPT_IDX];
      splat  = desc[ISEQ_ARGS_SPLAT_IDX];
      labels = desc[ISEQ_ARGS_LABELS_IDX];
      min    = nreq;
      max    = splat >= 0 ? -1 : nreq + nopt;

      this._checkArgumentCount(min, max, nargs);

      // copy arguments to local variables
      for (i = 0; i < nargs; i++) { frame.locals[i] = args[i]; }

      if (splat >= 0) {
        frame.locals[splat] = Bully.Array.make(args.slice(nreq + nopt));
      }

      if (nopt > 0) {
        frame.ip = nargs >= nreq + nopt ?
          iseq.labels[labels[labels.length - 1]] :
          iseq.labels[labels[nargs - nreq]];
      }
    }
  },

  _processISeqLabels: function(frame) {
    var iseq = frame.code, body = iseq[ISEQ_BODY_IDX], len = body.length, ins, i;

    frame.code.labels = {};

    for (i = 0; i < len; i++) {
      ins = body[i];
      if (typeof ins === 'string') { iseq.labels[ins] = i; }
    }
  },

  runMethodFrame: function(frame) {
    var ret = void 0, e;

    if (frame.isISeq && !frame.code.labels) { this._processISeqLabels(frame); }

    // check and setup arguments
    try { this._setupMethodArgs(frame); }
    catch (e) {
      if (!(e instanceof Bully.RaiseException)) { throw e; }
      frame.prevFrame.status = SF_STATUS_RAISE;
      this.currentException  = e.exception;
      return ret;
    }

    this.pushFrame(frame);

    // execute the method body
    if (frame.isISeq) {
      this.runISeqBody(frame);
      if (frame.status === SF_STATUS_NORMAL || frame.status === SF_STATUS_RETURN) {
        ret = frame.peek();
      }
    }
    else {
      try { ret = frame.code.call(null, frame.self, frame.args, frame.proc); }
      catch (e) {
        if (!(e instanceof Bully.RaiseException)) { throw e; }
        frame.status = SF_STATUS_RAISE;
        this.currentException = e.exception;
      }
    }

    if (frame.status === SF_STATUS_RAISE && frame.prevFrame) {
      frame.prevFrame.status = SF_STATUS_RAISE;
    }

    this.popFrame();

    return ret;
  },

  runClassFrame: function(frame) {
    var ret = void 0;

    if (frame.isISeq && !frame.code.labels) { this._processISeqLabels(frame); }

    this.pushFrame(frame);

    this.runISeqBody(frame);
    if (frame.status === SF_STATUS_NORMAL) {
      ret = frame.peek();
    }
    else if (frame.status === SF_STATUS_RAISE) {
      frame.prevFrame.status = SF_STATUS_RAISE;
    }

    this.popFrame();

    return ret;
  },

  runBlockFrame: function(frame) {
    var ret = void 0, e;

    if (frame.isISeq && !frame.code.labels) { this._processISeqLabels(frame); }

    // check and setup arguments
    // FIXME: process as block args
    try { this._setupMethodArgs(frame); }
    catch (e) {
      if (!(e instanceof Bully.RaiseException)) { throw e; }
      frame.prevFrame.status = SF_STATUS_RAISE;
      this.currentException  = e.exception;
      return ret;
    }

    this.pushFrame(frame);

    // execute the block body
    if (frame.isISeq) {
      this.runISeqBody(frame);
      if (frame.status === SF_STATUS_NORMAL || frame.status === SF_STATUS_RETURN) {
        ret = frame.peek();
      }
    }
    else {
      try { ret = frame.code.call(null, frame.self, frame.args); }
      catch (e) {
        if (!(e instanceof Bully.RaiseException)) { throw e; }
        frame.prevFrame.status = SF_STATUS_RAISE;
        this.currentException = e.exception;
      }
    }

    if (frame.status === SF_STATUS_RAISE) {
      frame.prevFrame.status = SF_STATUS_RAISE;
    }

    this.popFrame();

    return ret;
  },

  runISeqBody: function(frame) {
    var iseq = frame.code, body = iseq[ISEQ_BODY_IDX], len = body.length,
        tmpframe, retframe, e, ary, _super, mod, klass, sendargs, recv, proc,
        localvar;

    for (; frame.ip < len; frame.ip++) {
      ins = body[frame.ip];

      if (typeof ins !== 'object') { continue; }

      try {
        switch (ins[0]) {
          case 'pop':
            frame.pop();
            break;
          case 'dup':
            frame.push(frame.peek());
            break;
          case 'setn':
            frame.stack[frame.sp - 1 - ins[1]] = frame.stack[frame.sp - 1];
            break;
          case 'putnil':
            frame.push(null);
            break;
          case 'putself':
            frame.push(frame.self);
            break;
          case 'putbuiltin':
            frame.push(Bully[ins[1]]);
            break;
          case 'putcbase':
            frame.push(this.cbase());
            break;
          case 'putiseq':
            frame.push(ins[1]);
            break;
          case 'putobject':
            frame.push(ins[1]);
            break;
          case 'putstring':
            frame.push(Bully.String.make(ins[1]));
            break;
          case 'putsymbol':
            frame.push(ins[1]);
            break;
          case 'newarray':
            ary = new Array(ins[1]);
            for (i = ins[1] - 1; i >= 0; i--) { ary[i] = frame.pop(); }
            frame.push(Bully.Array.make(ary));
            break;
          case 'defineclass':
            _super = frame.pop();
            mod    = frame.pop();
            switch (ins[3]) {
              case VM_DEFINECLASS_TYPE_CLASS:
                klass = Bully.define_class_under(mod, ins[1], _super);
                break;
              case VM_DEFINECLASS_TYPE_SINGLETON_CLASS:
                klass = Bully.singleton_class(mod);
                break;
              case VM_DEFINECLASS_TYPE_MODULE:
                klass = Bully.define_module_under(mod, ins[1]);
                break;
              default: throw new Error('invalid defineclass type: ' + ins[3]);
            }
            this.pushModule(klass);
            frame.push(this.runClassFrame(new ClassFrame(ins[2], frame, klass)));
            this.popModule();
            break;
          case 'definemethod':
            mod = frame.pop();
            if (ins[3]) {
              // singleton method
              Bully.define_singleton_method(mod, ins[1], ins[2]);
            }
            else {
              // instance method
              Bully.define_method(mod, ins[1], ins[2]);
            }
            break;
          case 'send':
            sendargs = [];
            for (i = 0; i < ins[2]; i++) { sendargs.unshift(frame.pop()); }
            recv = frame.pop();
            proc = ins[3] ? this.makeProc(ins[3]) : null;
            frame.push(this.sendMethod(recv, ins[1], sendargs, proc));
            break;
          case 'invokesuper':
            sendargs = [];
            for (i = 0; i < ins[1]; i++) { sendargs.unshift(frame.pop()); }
            if (!frame.pop()) { sendargs = null; }
            frame.push(this.invokeSuper(sendargs, null));
            break;
          case 'invokeblock':
            proc = frame.isDynamic ? frame.code.defFrame.proc : frame.proc;
            if (!proc) {
              Bully.raise(Bully.LocalJumpError, 'no block given (yield)');
            }
            sendargs = [];
            for (i = 0; i < ins[1]; i++) { sendargs.unshift(frame.pop()); }
            frame.push(this.callProc(proc, sendargs));
            break;
          case 'setlocal':
            tmpframe = frame;
            while (tmpframe instanceof BlockFrame) { tmpframe = tmpframe.prevFrame; }
            tmpframe.locals[ins[1]] = frame.pop();
            break;
          case 'getlocal':
            tmpframe = frame;
            while (tmpframe instanceof BlockFrame) { tmpframe = tmpframe.prevFrame; }
            localvar = tmpframe.locals[ins[1]];
            frame.push(localvar === undefined ? null : localvar);
            break;
          case 'setinstancevariable':
            Bully.ivar_set(frame.self, ins[1], frame.pop());
            break;
          case 'getinstancevariable':
            frame.push(Bully.ivar_get(frame.self, ins[1]));
            break;
          case 'setdynamic':
            tmpframe = frame;
            for (i = 0; i < ins[2]; i++) {
              tmpframe = (tmpframe instanceof BlockFrame) ?
                tmpframe.localFrame : tmpframe.prevFrame;
            }
            tmpframe.locals[ins[1]] = frame.pop();
            break;
          case 'getdynamic':
            tmpframe = frame;
            for (i = 0; i < ins[2]; i++) {
              tmpframe = (tmpframe instanceof BlockFrame) ?
                tmpframe.localFrame : tmpframe.prevFrame;
            }
            frame.push(tmpframe.locals[ins[1]]);
            break;
          case 'getconstant':
            mod = frame.pop();
            frame.push(this.getConstant(mod, ins[1]));
            break;
          case 'setconstant':
            mod = frame.pop();
            Bully.const_set(mod, ins[1], frame.pop());
            break;
          case 'branchif':
            if (Bully.test(frame.pop())) { frame.ip = iseq.labels[ins[1]]; }
            break;
          case 'branchunless':
            if (!Bully.test(frame.pop())) { frame.ip = iseq.labels[ins[1]]; }
            break;
          case 'jump':
            frame.ip = iseq.labels[ins[1]];
            break;
          case 'throw':
            switch (ins[1]) {
              case VM_THROW_TYPE_RAISE:
                frame.status = frame_STATUS_RAISE;
                break;
              case VM_THROW_TYPE_RETURN:
                tmpframe = frame;
                retframe = frame.isLambda ? frame : frame.localFrame;

                tmpframe.status = SF_STATUS_RETURN;
                // FIXME: clean this up
                while (tmpframe && tmpframe !== retframe) {
                  tmpframe = tmpframe.prevFrame;
                  if (tmpframe) {
                    tmpframe.status = SF_STATUS_RETURN;
                  }
                }

                if (!tmpframe) {
                  Bully.raise(Bully.LocalJumpError, 'unexpected return');
                }
                break;
              case VM_THROW_TYPE_RETRY:
                frame.status = SF_STATUS_RETRY;
                frame.pop();
                break;
              default:
                throw new Error('invalid throw type: ' + throwType);
            }
            break;
          case 'leave':
            return;
          default:
            throw new Error('unknown opcode: ' + ins[0]);
        }
      }
      catch (e) {
        if (!(e instanceof Bully.RaiseException)) { throw e; }
        frame.status = SF_STATUS_RAISE;
        this.currentException = e.exception;
      }

      // check to see if an exception was raised or bubbled up
      if (frame.status === SF_STATUS_RAISE) {
        this.handleException(frame);
        if (frame.status === SF_STATUS_RAISE) {
          // exception was not handled, so stop running this frame and allow it
          // to bubble
          return;
        }
      }
      else if (frame.status === SF_STATUS_RETURN || frame.status === SF_STATUS_RETRY) {
        return;
      }
    }
  },

  // Private: Checks that the number of arguments passed to a method are acceptable.
  //
  // Bully methods can accept a fixed number of arguments, optional arguments, and
  // splat arguments.  When methods are defined, their minimum and maximum number
  // of arguments are calculated from the method signature.  Those values are used
  // here to check whether the number of arguments passed is acceptable.  If an
  // incorrect number of arguments are passed, then an ArgumentError exception is
  // raised.
  //
  // min   - The minimum number of arguments the method accepts.
  // max   - The maximum number of arguments the method accepts.
  // nargs - The number of arguments passed to the method.
  //
  // Returns nothing.
  // Raises ArgumentError if an incorrect number of arguments are passed.
  _checkArgumentCount: function(min, max, nargs) {
    var msg = 'wrong number of arguments (';

    if (min === max) {
      // 0 or more required arguments, no optionals
      if (nargs !== min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
    else if (max === -1) {
      // no limit on args
      if (nargs < min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
    else {
      // bounded number of args
      if (nargs < min) {
        msg += nargs + ' for ' + min + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
      else if (nargs > max) {
        msg += nargs + ' for ' + max + ')';
        Bully.raise(Bully.ArgumentError, msg);
      }
    }
  },

  setupISeqArgs: function(sf) {
    var iseq   = sf.code,
        args   = sf.args,
        nargs  = args.length,
        desc   = iseq[ISEQ_ARGS_IDX],
        nreq   = desc[ISEQ_ARGS_NUM_REQ_IDX],
        nopt   = desc[ISEQ_ARGS_NUM_OPT_IDX],
        splat  = desc[ISEQ_ARGS_SPLAT_IDX],
        labels = desc[ISEQ_ARGS_LABELS_IDX],
        min    = nreq,
        max    = splat >= 0 ? -1 : nreq + nopt,
        i;

    this._checkArgumentCount(min, max, nargs);

    // copy arguments to local variables
    for (i = 0; i < nargs; i++) { sf.locals[i] = args[i]; }

    if (splat >= 0) {
      sf.locals[splat] = Bully.Array.make(args.slice(nreq + nopt));
    }

    if (nopt > 0) {
      sf.ip = nargs >= nreq + nopt ?
        iseq.labels[labels[labels.length - 1]] :
        iseq.labels[labels[nargs - nreq]];
    }
  },

  // Looks up and invokes a method on the given receiver object.  If the method
  // cannot be found anywhere in the object's inheritance chain, the method
  // 'method_missing' will be sent to the object instead.
  //
  // If sendMethod is called in the context of a stack frame (via the 'send'
  // instruction) then it will place the return value of the method onto the
  // stack.  If sendMethod is called outside the context of a stack frame (e.g.
  // a method implemented in javascript calls it) then the return value of
  // them method is simply returned.
  //
  // Method dispatch is very straightforward, we simply start with the given
  // object's class and check to see if the method is defined in its m_tbl
  // property.  If the method is not found, we simply traverse the superclass
  // chain until it can be located.  If the method is not found, the process
  // starts over again to look for the 'method_missing' method.
  //
  // recv  - The object to invoke the method on.
  // name  - The name of the method to invoke.
  // args  - A javascript array containing the arguments to send (optional).
  // proc  - FIXME (optional).
  //
  // Returns the return value of the method.
  sendMethod: function(recv, name, args, proc) {
    var method = Bully.find_method(Bully.class_of(recv), name);

    args = args || [];

    if (!method) {
      args.unshift(name);
      return this.sendMethod(recv, 'method_missing', args, proc);
    }

    return this.runMethodFrame(
      new MethodFrame(method, this.currentFrame, recv, args, proc));
  },

  invokeSuper: function(args, proc) {
    var frame       = this.currentFrame,
        methodFrame = this.currentMethodFrame(),
        klass       = methodFrame.code.klass,
        method      = Bully.find_method(klass._super, methodFrame.name);

    if (!method) {
      Bully.raise(Bully.NoMethodError, "super: no superclass method '" +
        methodFrame.name + "' for " + send(frame.self, 'inspect').data);
    }

    return this.runMethodFrame(new MethodFrame(method, this.currentFrame,
      frame.self, args || frame.args, proc));
  },

  makeProc: function(block) {
    var proc = Bully.make_object(block, Bully.Proc);

    proc.localFrame = this.currentFrame;
    proc.isLambda   = false;

    // FIXME
    proc.min_args   = 0;
    proc.max_args   = -1;

    return proc;
  },

  callProc: function(proc, args) {
    var frame = this.currentFrame;
    return this.runBlockFrame(
      new BlockFrame(proc, frame, proc.localFrame, frame.self, args, []));
  },

  currentNesting: function() {
    var frame = this.currentFrame;

    while ((frame instanceof BlockFrame) || frame.type === 'jsmethod') {
      frame = (frame instanceof BlockFrame) ? frame.localFrame : frame.prevFrame;
    }

    if (frame.type === 'top') { return []; }

    return ((frame instanceof MethodFrame) ?
      frame.code.lexicalModules : Bully.VM.lexicalModules).slice().reverse();
  },

  getConstant: function(mod, name) {
    var cbase, modules, i;

    if (mod) { return Bully.const_get(mod, name); }

    // need to perform a lexical lookup
    cbase = this.cbase();
    modules = this.currentNesting().concat(Bully.Module.ancestors(cbase));

    if (cbase !== Bully.Object) {
      modules = modules.concat(Bully.Module.ancestors(Bully.Object));
    }

    for (i = 0; i < modules.length; i++) {
      if (Bully.const_defined(modules[i], name, false)) {
        return Bully.const_get(modules[i], name);
      }
    }

    return this.sendMethod(modules[0], 'const_missing', [name], null);
  },

  handleException: function(frame) {
    var iseq        = frame.code,
        rescueEntry = this._findCatchEntry('rescue', frame),
        ensureEntry = this._findCatchEntry('ensure', frame),
        retryEntry, rescueFrame;

    if (!rescueEntry && !ensureEntry) { return; }

    if (rescueEntry) {
      frame.sp = rescueEntry[CATCH_ENTRY_SP_IDX];
      frame.ip = iseq.labels[rescueEntry[CATCH_ENTRY_CONT_LBL_IDX]];
      rescueFrame = new BlockFrame(
        rescueEntry[CATCH_ENTRY_ISEQ_IDX], frame, frame, frame.self, [],
        [this.currentException]);
      frame.push(this.runBlockFrame(rescueFrame));

      if (rescueFrame.status === SF_STATUS_NORMAL) {
        // the exception was rescued, so continue executing the current frame
        frame.status = SF_STATUS_NORMAL;
        this.currentException = null;
        return;
      }
      else if (rescueFrame.status === SF_STATUS_RETRY) {
        retryEntry = this._findCatchEntry('retry', frame);
        frame.sp = retryEntry[CATCH_ENTRY_SP_IDX];
        frame.ip = iseq.labels[retryEntry[CATCH_ENTRY_CONT_LBL_IDX]];
        frame.status = SF_STATUS_NORMAL;
        this.currentException = null;
        return;
      }
    }

    // the exception hasn't been rescued yet, so run the matching ensure entry
    // if it exists and let the exception bubble up
    if (ensureEntry) {
      frame.sp = ensureEntry[CATCH_ENTRY_SP_IDX];
      frame.ip = iseq.labels[ensureEntry[CATCH_ENTRY_CONT_LBL_IDX]];
      this.runBlockFrame(new BlockFrame(
        ensureEntry[CATCH_ENTRY_ISEQ_IDX], frame, frame,
        frame.self, [], [this.currentException]));
    }
  },

  _findCatchEntry: function(type, frame) {
    var catchTable = frame.code[ISEQ_CATCH_TBL_IDX],
        len        = catchTable.length,
        labels     = frame.code.labels,
        entry, entryType, start, stop, i;

    for (i = 0; i < len; i++) {
      entry     = catchTable[i];
      entryType = entry[CATCH_ENTRY_TYPE_IDX];
      start     = labels[entry[CATCH_ENTRY_START_LBL_IDX]];
      stop      = labels[entry[CATCH_ENTRY_STOP_LBL_IDX]];

      if (entryType === type && start <= frame.ip && frame.ip <= stop) {
        return entry;
      }
    }

    return null;
  }
};

}());

