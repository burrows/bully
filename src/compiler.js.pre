
#define COMPILE_NODE(node, ...) this['compile' + (node).type](node, ##__VA_ARGS__)

(function() {

var ISeq, Instruction, Label;

ISeq = function(name, type) {
  this.name              = name;
  this.type              = type;
  this.instructions      = [];
  this.numRequiredArgs   = 0;
  this.optionalArgLabels = [];
  this.bodyStartLabel    = null;
  this.splatIndex        = -1;
  this.locals            = [];
  this.catchEntries      = [];
  this.currentStackSize  = 0;
  this.maxStackSize      = 0;
  this.nextLabelNumber   = 0;

  return this;
};

ISeq.prototype = {
  setRequiredArgs: function(argNames) {
    var len = argNames.length, i;

    this.numRequiredArgs = len;

    for (i = 0; i < len; i++) {
      this.addLocal(argNames[i]);
    }

    return this;
  },

  addOptionalArg: function(name) {
    var label = this.newLabel('optarg-' + name),
        idx   = this.addLocal(name);

    this.optionalArgLabels.push(label);

    return {index: idx, label: label};
  },

  setSplatArg: function(name) {
    this.splatIndex = this.addLocal(name);

    return this;
  },

  labelBodyStart: function() {
    this.bodyStartLabel = this.newLabel('bodystart');

    this.setLabel(this.bodyStartLabel);

    return this.bodyStartLabel;
  },

  addInstruction: function(opcode) {
    var insn = new Instruction(opcode,
      Array.prototype.slice.call(arguments, 1));

    this.instructions.push(insn);
    this.currentStackSize += Instruction.stackDelta(insn);

    if (this.currentStackSize > this.maxStackSize) {
      this.maxStackSize = this.currentStackSize;
    }

    return this;
  },

  newLabel: function(name) {
    return new Label(++this.nextLabelNumber, name);
  },

  setLabel: function(label) {
    label.position = this.currentPosition();
    label.sp = this.currentStackSize;

    this.instructions.push(label);

    return this;
  },

  addCatchEntry: function(entry) {
    this.catchEntries.push(entry);
    return this;
  },

  currentPosition: function() {
    return this.instructions.length;
  },

  hasLocal: function(name) {
    return this.locals.indexOf(name) !== -1;
  },

  addLocal: function(name) {
    this.locals.push(name);
    return this.locals.length - 1;
  },

  localIndex: function(name) {
    var idx = this.locals.indexOf(name);

    return idx === -1 ? this.addLocal(name) : idx;
  },

  #define ISEQ_NAME_IDX      1
  #define ISEQ_TYPE_IDX      2
  #define ISEQ_MAX_STACK_IDX 3
  #define ISEQ_LOCALS_IDX    4
  #define ISEQ_ARGS_IDX      5
  #define ISEQ_CATCH_TBL_IDX 6
  #define ISEQ_BODY_IDX      7

  #define ISEQ_ARGS_NUM_REQ_IDX 0
  #define ISEQ_ARGS_NUM_OPT_IDX 1
  #define ISEQ_ARGS_SPLAT_IDX   2
  #define ISEQ_ARGS_LABELS_IDX  3

  // Converts the ISeq object to a raw instruction sequence executable by the
  // VM.
  //
  // Format is as follows:
  //
  // Index Description
  // ----- ---------------------------------------------------------------------
  // 0     "BullyISeq"
  // 1     name
  // 2     type (top, class, module, method, or block)
  // 3     maximum stack size
  // 4     array of local variable names
  // 5     arguments description
  // 6     catch table
  // 7     body
  toRaw: function() {
    var args = new Array(4),
        nopt = this.optionalArgLabels.length,
        ic   = this.instructions.length,
        result, i;

    args[ISEQ_ARGS_NUM_REQ_IDX] = this.numRequiredArgs;
    args[ISEQ_ARGS_NUM_OPT_IDX] = nopt;
    args[ISEQ_ARGS_SPLAT_IDX]   = this.splatIndex;
    args[ISEQ_ARGS_LABELS_IDX]  = new Array(nopt + 1);

    if (nopt > 0) {
      for (i = 0; i < nopt; i++) {
        args[ISEQ_ARGS_LABELS_IDX][i] = this.optionalArgLabels[i].toRaw();
      }
      args[ISEQ_ARGS_LABELS_IDX][nopt] = this.bodyStartLabel.toRaw();
    }

    result = new Array(
      'BullyInstructionSequence',
      this.name,
      this.type,
      this.maxStackSize,
      this.locals,
      args,
      [],
      new Array(ic)
    );

    for (i = 0; i < ic; i++) {
      result[7][i] = this.instructions[i].toRaw();
    }

    return result;
  }
};

Instruction = function(opcode, operands) {
  this.opcode   = opcode;
  this.operands = operands;

  return this;
};

Instruction.ConstantStackDeltas = {
  nop:               0,
  putnil:            1,
  putstring:         1,
  putbuiltin:        1,
  putcurrentmodule:  1,
  putiseq:           1,
  putobject:         1,
  putself:           1,
  getlocal:          1,
  setlocal:         -1,
  getconstant:       0,
  pop:              -1,
  definemethod:     -2,
  branchif:         -1,
  branchunless:     -1,
  jump:              0
};

Instruction.stackDelta = function(insn) {
  var opcode = insn.opcode, constants = this.ConstantStackDeltas;

  if (insn instanceof Label) { return 0; }
  else if (insn.opcode in constants) { return constants[opcode]; }

  switch (opcode) {
    case 'send':
      return -insn.operands[0];
    default:
      throw new Error('invalid opcode: ' + insn.opcode);
  }
};

Instruction.prototype = {
  toRaw: function() {
    var a = [this.opcode], len = this.operands.length, op, i;

    for (i = 0; i < len; i++) {
      op = this.operands[i];
      a.push(typeof op === 'object' ? op.toRaw() : op);
    }

    return a;
  }
};

Label = function(number, name) {
  this.number   = number;
  this.name     = name || 'label';
  this.position = null;
  this.sp       = null;

  return this;
};

Label.prototype = {
  toRaw: function() {
    return this.name + '-' + this.number;
  }
};

//------------------------------------------------------------------------------

Bully.Compiler = {
  compile: function(node) {
    var iseq = new ISeq('<compiled>', 'top');

    COMPILE_NODE(node, iseq, true);

    return iseq.toRaw();
  },

  compileBody: function(node, iseq, push) {
    var lines = node.lines, len = lines.length, i;

    for (i = 0; i < len; i++) {
      COMPILE_NODE(lines[i], iseq, push && (i === len - 1));
    }
  },

  compileCall: function(node, iseq, push) {
    var argLen   = node.args ? node.args.length : 0,
        localIdx, i;

    // check to see if this is actually a local variable reference
    if (!node.expression && !node.args && iseq.hasLocal(node.name)) {
      if (push) { iseq.addInstruction('getlocal', iseq.localIndex(node.name)); }
      return;
    }

    // add receiver
    if (node.expression) {
      COMPILE_NODE(node.expression, iseq, true);
    }
    else {
      iseq.addInstruction('putself');
    }

    // add arguments
    for (i = 0; i < argLen; i += 1) {
      COMPILE_NODE(node.args[i], iseq, true);
    }

    iseq.addInstruction('send', node.name, argLen);

    if (!push) { iseq.addInstruction('pop'); }
  },

  compileParamList: function(node, iseq, push) {
    var nreq = node.required.length,
        nopt = node.optional.length,
        labels = [], optArg, i;

    // setup local variables
    iseq.setRequiredArgs(node.required);

    for (i = 0; i < nopt; i++) {
      optArg = iseq.addOptionalArg(node.optional[i].name);
      iseq.setLabel(optArg.label);
      COMPILE_NODE(node.optional[i].expression, iseq, true);
      iseq.addInstruction('setlocal', optArg.index);
    }

    if (nopt > 0) { iseq.labelBodyStart(); }

    if (node.splat) { iseq.setSplatArg(node.splat); }
  },

  compileDef: function(node, iseq, push) {
    var defiseq = new ISeq(node.name, 'method');

    if (node.params) { COMPILE_NODE(node.params, defiseq, push); }

    COMPILE_NODE(node.body, defiseq, false);

    iseq.addInstruction('putcurrentmodule');
    iseq.addInstruction('putiseq', defiseq);
    iseq.addInstruction('definemethod', node.name, false);

    if (push) { iseq.addInstruction('putnil'); }
  },

  compileLocalAssign: function(node, iseq, push) {
    var idx = iseq.localIndex(node.name);

    COMPILE_NODE(node.expression, iseq, true);

    iseq.addInstruction('setlocal', idx);
  },

  compileNumberLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', parseFloat(node.value));
  },

  compileStringLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putstring', node.value);
  },

  compileTrueLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', true);
  },

  compileFalseLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', false);
  },

  compileIf: function(node, iseq, push) {
    var labels = [], len = node.conditions.length, endLabel, lines, i, j;

    for (i = 0; i < len; i++) { labels.push(iseq.newLabel()); }

    endLabel = node.else_body ? iseq.newLabel() : labels[len - 1];

    for (i = 0; i < len; i++) {
      COMPILE_NODE(node.conditions[i], iseq, true);
      iseq.addInstruction('branchunless', labels[i]);
      COMPILE_NODE(node.bodies[i], iseq, push); 

      if (i !== len - 1 || node.else_body) {
        iseq.addInstruction('jump', endLabel);
      }

      iseq.setLabel(labels[i]);
    }

    if (node.else_body) {
      COMPILE_NODE(node.else_body, iseq, push); 
      iseq.setLabel(endLabel);
    }
  },

  compileConstantRef: function(node, iseq, push) {
    var len = node.names.length, i;

    if (node.global) {
      iseq.addInstruction('putbuiltin', 'Object');
    }
    else {
      iseq.addInstruction('putnil');
    }

    iseq.addInstruction('getconstant', node.names[0]);

    for (i = 1; i < len; i++) {
      iseq.addInstruction('getconstant', node.names[i]);
    }

    if (!push) { iseq.addInstruction('pop'); }
  },

  compileRescueBlocks: function(rescueNodes, ctx, labels, push) {
    var body = [], len = rescueNodes.length, rescueNode, rescueCtx, iseq, i, j;

    rescueCtx = new ISeqContext({
      name: 'rescue in ' + ctx.name,
      type: 'rescue'
    });

    for (i = 0; i < len; i++) {
      rescueNode = rescueNodes[i];

      for (j = 0; j < rescueNode.exception_types.length; j++) {
        COMPILE_NODE(rescueNode.exception_types[j], body, rescueCtx, true);
      }

      this.compileBody(rescueNodes[i].body, body, rescueCtx, push);
    }

    iseq = this.createISeq(rescueCtx, body);

    ctx.catchTable.push([
      'rescue', iseq, labels.start, labels.end, labels.cont, 0
    ]);
  },

  compileBeginBlock: function(node, iseq, ctx, push) {
    var labels = {
      start: this.nextLabel(),
      end: this.nextLabel(),
      cont: this.nextLabel()
    };

    iseq.push(labels.start);
    this.compileBody(node.body, iseq, ctx, push);
    iseq.push(labels.end);
    iseq.push(['nop']);
    iseq.push(labels.cont);

    this.compileRescueBlocks(node.rescues, ctx, labels, push);
  },

  nextLabel: function() {
    this.nextLabelId++;
    return 'label_' + this.nextLabelId;
  }
};

}());

