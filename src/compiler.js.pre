
#define COMPILE_NODE(node, ...) this['compile' + (node).type](node, ##__VA_ARGS__)

(function() {

var ISeqContext = function(opts) {
  opts = opts || {};

  this.name   = opts.name   || "";
  this.type   = opts.type   || "";
  this.locals = opts.locals || [];
  this.args   = { desc: [0,0,[]], insns: [] };

  return this;
};

ISeqContext.prototype = {
};

Bully.Compiler = {
  compile: function(node) {
    var ctx = new ISeqContext({ name: '<compiled>', type: 'top' });

    this.nextLabelId = 0;

    return this.compileISeq(node, ctx);
  },

  #define ISEQ_NAME_IDX   1
  #define ISEQ_TYPE_IDX   2
  #define ISEQ_LOCALS_IDX 3
  #define ISEQ_ARGS_IDX   4
  #define ISEQ_BODY_IDX   5

  // Compiles a Body node into an instruction sequence.  The format is as
  // follows:
  //
  // Index Description
  // ----- ---------------------------------------------------------------------
  // 0     opcode (iseq)
  // 1     name
  // 2     type (top, class, module, method, block)
  // 3     array of local variable names
  // 4     arguments description
  // 5     instruction sequence body
  //
  // node - The Body node to compile.
  // ctx  - An instance of ISeqContext.
  //
  // Returns the compiled instruction sequence.
  compileISeq: function(node, ctx) {
    var len = node.lines.length, body = [], i;

    for (i = 0; i < len; i += 1) {
      COMPILE_NODE(node.lines[i], body, ctx, i === len - 1);
    }

    return [
      'iseq',
      ctx.name,
      ctx.type,
      ctx.locals,
      ctx.args.desc,
      ctx.args.insns.concat(body)
    ];
  },

  // Compiles a Body node into an existing instruction sequence.  This is used
  // for AST Body nodes that don't get compiled into a new instruction sequence
  // (e.g. the bodies of an If expression).
  //
  // node - The Body node to compile.
  // iseq - The instruction sequence to append the compiled instructions to.
  // ctx  - An instance of ISeqContext.
  // push - A boolean indicating whether or not the result of this expression
  //        should be pushed onto the stack.
  //
  // Returns nothing.
  compileBody: function(node, iseq, ctx, push) {
    var lines = node.lines, len = lines.length, i;

    for (i = 0; i < len; i++) {
      COMPILE_NODE(lines[i], iseq, ctx, push && (i === len - 1));
    }
  },

  compileCall: function(node, iseq, ctx, push) {
    var argLen   = node.args ? node.args.length : 0,
        localIdx = ctx.locals.indexOf(node.name),
        i;

    // check to see if this is actually a local variable reference
    if (!node.expression && !node.args && localIdx !== -1) {
      if (push) { iseq.push(['getlocal', localIdx]); }
      return;
    }

    // add receiver
    if (node.expression) {
      COMPILE_NODE(node.expression, iseq, ctx, true);
    }
    else {
      iseq.push(['putnil']);
    }

    // add arguments
    for (i = 0; i < argLen; i += 1) {
      COMPILE_NODE(node.args[i], iseq, ctx, true);
    }

    iseq.push(['send', node.name, argLen]);

    if (!push) { iseq.push(['pop']); }
  },

  #define ARGS_NUM_REQ_IDX 0
  #define ARGS_NUM_OPT_IDX 1
  #define ARGS_SPLAT_IDX   2
  #define ARGS_LABELS_IDX  3
  compileParamList: function(node, iseq, ctx, push) {
    var nreq = node.required.length, nopt = node.optional.length, labels = [],
        splatIdx = -1, label, i;

    // setup local variables
    for (i = 0; i < nreq; i++) {
      ctx.locals.push(node.required[i]);
    }

    for (i = 0; i < nopt; i++) {
      label = this.nextLabel();
      labels.push(label);
      ctx.locals.push(node.optional[i].name);
      ctx.args.insns.push(label);
      COMPILE_NODE(node.optional[i].expression, ctx.args.insns, ctx, true);
      ctx.args.insns.push(['setlocal', nreq + i]);
    }

    if (node.optional.length > 0) {
      label = this.nextLabel();
      labels.push(label);
      ctx.args.insns.push(label);
    }

    if (node.splat) {
      splatIdx = ctx.locals.length;
      ctx.locals.push(node.splat);
    }

    ctx.args.desc = [
      node.required.length,
      node.optional.length,
      splatIdx,
      labels
    ];
  },

  compileDef: function(node, iseq, ctx, push) {
    var defctx = new ISeqContext({name: node.name, type: 'method'}), body;

    if (node.params) {
      this.compileParamList(node.params, iseq, defctx, false);
    }

    body = this.compileISeq(node.body, defctx);

    iseq.push(['putcurrentmodule']);
    iseq.push(['putiseq', body]);
    iseq.push(['definemethod', node.name, false]);

    if (push) { iseq.push(['putnil']); }
  },

  compileLocalAssign: function(node, iseq, ctx, push) {
    var idx = ctx.locals.indexOf(node.name);

    if (idx === -1) {
      idx = ctx.locals.length;
      ctx.locals.push(node.name);
    }

    COMPILE_NODE(node.expression, iseq, ctx, true);
    iseq.push(['setlocal', idx]);
  },

  compileNumberLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putobject', parseFloat(node.value)]);
  },

  compileStringLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putstring', node.value]);
  },

  compileTrueLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putobject', true]);
  },

  compileFalseLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putobject', false]);
  },

  compileIf: function(node, iseq, ctx, push) {
    var labels = [], len = node.conditions.length, endLabel, lines, i, j;

    for (i = 0; i < len; i++) { labels.push(this.nextLabel()); }

    endLabel = node.else_body ? this.nextLabel() : labels[len - 1];

    for (i = 0; i < len; i++) {
      COMPILE_NODE(node.conditions[i], iseq, ctx, true);
      iseq.push(['branchunless', labels[i]]);
      COMPILE_NODE(node.bodies[i], iseq, ctx, push); 

      if (i !== len - 1 || node.else_body) {
        iseq.push(['jump', endLabel]);
      }

      iseq.push(labels[i]);
    }

    if (node.else_body) {
      COMPILE_NODE(node.else_body, iseq, ctx, push); 
      iseq.push(endLabel);
    }
  },

  nextLabel: function() {
    this.nextLabelId++;
    return 'label_' + this.nextLabelId;
  }
};

}());

