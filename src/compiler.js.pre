
#define COMPILE_NODE(node, ...) this['compile' + (node).type](node, ##__VA_ARGS__)

(function() {

var ISeq, Instruction, Label;

ISeq = function(name, type) {
  this.name             = name;
  this.type             = type;
  this.instructions     = [];
  this.locals           = [];
  this.catchEntries     = [];
  this.currentStackSize = 0;
  this.maxStackSize     = 0;
  this.labelNumber      = 0;

  return this;
};

ISeq.prototype = {
  addInstruction: function(opcode) {
    var insn = new Instruction(opcode,
                               Array.prototype.slice.call(arguments, 1));

    this.instructions.push(insn);
    this.currentStackSize += Instruction.stackDelta(insn);

    if (this.currentStackSize > this.maxStackSize) {
      this.maxStackSize = this.currentStackSize;
    }
  },

  setLabel: function() {
    var label = new Label(this.nextLabelNumber(),
                          this.currentPosition(),
                          this.currentStackSize);

    this.instructions.push(label);

    return label;
  },

  addCatchEntry: function(entry) {
    this.catchEntries.push(entry);
  },

  nextLabelNumber: function() {
    return ++this.labelNumber;
  },

  currentPosition: function() {
    return this.instructions.length;
  },

  hasLocal: function(name) {
    return this.locals.indexOf(name) !== -1;
  },

  localIndex: function(name) {
    var idx = this.locals.indexOf(name);

    if (idx === -1) {
      this.locals.push(name);
      idx = this.locals.length - 1;
    }

    return idx;
  },

  #define ISEQ_MISC_IDX      1
  #define ISEQ_NAME_IDX      2
  #define ISEQ_TYPE_IDX      3
  #define ISEQ_LOCALS_IDX    4
  #define ISEQ_ARGS_IDX      5
  #define ISEQ_CATCH_TBL_IDX 6
  #define ISEQ_BODY_IDX      7
  // Converts the ISeq object to a raw instruction sequence consumable by the
  // VM.
  //
  // Format is as follows:
  //
  // Index Description
  // ----- ---------------------------------------------------------------------
  // 0     "BullyISeq"
  // 1     hash containing number of arguments, local vars and max stack size
  // 2     name
  // 3     type (top, class, module, method, block)
  // 4     array of local variable names
  // 5     arguments description
  // 6     catch table
  // 7     instruction sequence body
  toRawInstruction: function() {
    var result = [
      'BullyInstructionSequence',
      {
        arg_size: 0,
        local_size: this.locals.length,
        stack_max: this.maxStackSize
      },
      this.name,
      this.type,
      this.locals,
      [],
      [],
      []
    ], len = this.instructions.length, i;

    for (i = 0; i < len; i++) {
      result[7].push(this.instructions[i].toRawInstruction());
    }

    return result;
  }
};

Instruction = function(opcode, operands) {
  this.opcode   = opcode;
  this.operands = operands;

  return this;
};

Instruction.stackDelta = function(insn) {
  if (insn instanceof Label) { return 0; }

  switch (insn.opcode) {
    case 'nop':
      return 0;
    case 'putnil':
      return 1;
    case 'getlocal':
      return 1;
    case 'setlocal':
      return -1;
    case 'putiseq':
      return 1;
    case 'send':
      return -insn.operands[0];
    case 'putobject':
      return 1;
    case 'putself':
      return 1;
    default:
      throw new Error('invalid opcode: ' + insn.opcode);
  }
};

Instruction.prototype = {
  toRawInstruction: function() {
    return [this.opcode].concat(this.operands);
  }
};

Label = function(number, position, sp) {
  this.number   = number;
  this.position = position;
  this.sp       = sp;

  return this;
};

Label.prototype = {
  toRawInstruction: function() {
    return 'label_' + this.number;
  }
};

//------------------------------------------------------------------------------

Bully.Compiler = {
  compile: function(node) {
    var iseq = new ISeq('<compiled>', 'top');

    COMPILE_NODE(node, iseq, true);

    return iseq.toRawInstruction();
  },

  compileBody: function(node, iseq, push) {
    var lines = node.lines, len = lines.length, i;

    for (i = 0; i < len; i++) {
      COMPILE_NODE(lines[i], iseq, push && (i === len - 1));
    }
  },

  compileCall: function(node, iseq, push) {
    var argLen   = node.args ? node.args.length : 0,
        localIdx, i;

    // check to see if this is actually a local variable reference
    if (!node.expression && !node.args && iseq.hasLocal(node.name)) {
      if (push) { iseq.addInstruction('getlocal', iseq.localIndex(node.name)); }
      return;
    }

    // add receiver
    if (node.expression) {
      COMPILE_NODE(node.expression, iseq, true);
    }
    else {
      iseq.addInstruction('putself');
    }

    // add arguments
    for (i = 0; i < argLen; i += 1) {
      COMPILE_NODE(node.args[i], iseq, true);
    }

    iseq.addInstruction('send', node.name, argLen);

    if (!push) { iseq.addInstruction('pop'); }
  },

  #define ARGS_NUM_REQ_IDX 0
  #define ARGS_NUM_OPT_IDX 1
  #define ARGS_SPLAT_IDX   2
  #define ARGS_LABELS_IDX  3
  compileParamList: function(node, iseq, ctx, push) {
    var nreq = node.required.length, nopt = node.optional.length, labels = [],
        splatIdx = -1, label, i;

    // setup local variables
    for (i = 0; i < nreq; i++) {
      ctx.locals.push(node.required[i]);
    }

    for (i = 0; i < nopt; i++) {
      label = this.nextLabel();
      labels.push(label);
      ctx.locals.push(node.optional[i].name);
      ctx.args.insns.push(label);
      COMPILE_NODE(node.optional[i].expression, ctx.args.insns, ctx, true);
      ctx.args.insns.push(['setlocal', nreq + i]);
    }

    if (node.optional.length > 0) {
      label = this.nextLabel();
      labels.push(label);
      ctx.args.insns.push(label);
    }

    if (node.splat) {
      splatIdx = ctx.locals.length;
      ctx.locals.push(node.splat);
    }

    ctx.args.desc = [
      node.required.length,
      node.optional.length,
      splatIdx,
      labels
    ];
  },

  compileDef: function(node, iseq, ctx, push) {
    var defctx = new ISeqContext({name: node.name, type: 'method'}), body;

    if (node.params) {
      this.compileParamList(node.params, iseq, defctx, false);
    }

    body = this.compileISeq(node.body, defctx);

    iseq.push(['putcurrentmodule']);
    iseq.push(['putiseq', body]);
    iseq.push(['definemethod', node.name, false]);

    if (push) { iseq.push(['putnil']); }
  },

  compileLocalAssign: function(node, iseq, push) {
    var idx = iseq.localIndex(node.name);

    COMPILE_NODE(node.expression, iseq, true);

    iseq.addInstruction('setlocal', idx);
  },

  compileNumberLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', parseFloat(node.value));
  },

  compileStringLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putstring', node.value]);
  },

  compileTrueLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putobject', true]);
  },

  compileFalseLiteral: function(node, iseq, ctx, push) {
    if (!push) { return; }
    iseq.push(['putobject', false]);
  },

  compileIf: function(node, iseq, ctx, push) {
    var labels = [], len = node.conditions.length, endLabel, lines, i, j;

    for (i = 0; i < len; i++) { labels.push(this.nextLabel()); }

    endLabel = node.else_body ? this.nextLabel() : labels[len - 1];

    for (i = 0; i < len; i++) {
      COMPILE_NODE(node.conditions[i], iseq, ctx, true);
      iseq.push(['branchunless', labels[i]]);
      COMPILE_NODE(node.bodies[i], iseq, ctx, push); 

      if (i !== len - 1 || node.else_body) {
        iseq.push(['jump', endLabel]);
      }

      iseq.push(labels[i]);
    }

    if (node.else_body) {
      COMPILE_NODE(node.else_body, iseq, ctx, push); 
      iseq.push(endLabel);
    }
  },

  compileConstantRef: function(node, iseq, ctx, push) {
    var len = node.names.length, i;

    if (node.global) {
      // FIXME: should be able to do this with putobject
      iseq.push(['putnil']);
      iseq.push(['getconstant', 'Object']);
    }
    else {
      iseq.push(['putnil']);
    }

    iseq.push(['getconstant', node.names[0]]);

    for (i = 1; i < len; i++) {
      iseq.push(['getconstant', node.names[i]]);
    }

    if (!push) { iseq.push(['pop']); }
  },

  compileRescueBlocks: function(rescueNodes, ctx, labels, push) {
    var body = [], len = rescueNodes.length, rescueNode, rescueCtx, iseq, i, j;

    rescueCtx = new ISeqContext({
      name: 'rescue in ' + ctx.name,
      type: 'rescue'
    });

    for (i = 0; i < len; i++) {
      rescueNode = rescueNodes[i];

      for (j = 0; j < rescueNode.exception_types.length; j++) {
        COMPILE_NODE(rescueNode.exception_types[j], body, rescueCtx, true);
      }

      this.compileBody(rescueNodes[i].body, body, rescueCtx, push);
    }

    iseq = this.createISeq(rescueCtx, body);

    ctx.catchTable.push([
      'rescue', iseq, labels.start, labels.end, labels.cont, 0
    ]);
  },

  compileBeginBlock: function(node, iseq, ctx, push) {
    var labels = {
      start: this.nextLabel(),
      end: this.nextLabel(),
      cont: this.nextLabel()
    };

    iseq.push(labels.start);
    this.compileBody(node.body, iseq, ctx, push);
    iseq.push(labels.end);
    iseq.push(['nop']);
    iseq.push(labels.cont);

    this.compileRescueBlocks(node.rescues, ctx, labels, push);
  },

  nextLabel: function() {
    this.nextLabelId++;
    return 'label_' + this.nextLabelId;
  }
};

}());

