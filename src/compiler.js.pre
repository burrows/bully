
#define COMPILE_NODE(node, ...) this['compile' + (node).type](node, ##__VA_ARGS__)

(function() {

var ISeq, Instruction, Label;

ISeq = function(type, name) {
  this.name              = name;
  this.type              = type;
  this.instructions      = [];
  this.parentISeq        = null;
  this.localISeq         = this;
  this.numRequiredArgs   = 0;
  this.optionalArgLabels = [];
  this.bodyStartLabel    = null;
  this.splatIndex        = -1;
  this.locals            = [];
  this.catchEntries      = [];
  this.currentStackSize  = 0;
  this.maxStackSize      = 0;
  this.nextLabelNumber   = 0;

  return this;
};

ISeq.prototype = {
  newChildISeq: function(type, name) {
    var iseq = new ISeq(type, name);

    iseq.parentISeq = this;

    if (type === 'rescue') {
      iseq.localISeq = this;
    }
    else {
      iseq.localISeq = iseq;
    }

    return iseq;
  },

  setRequiredArgs: function(argNames) {
    var len = argNames.length, i;

    this.numRequiredArgs = len;

    for (i = 0; i < len; i++) {
      this.addLocal(argNames[i]);
    }

    return this;
  },

  addOptionalArg: function(name) {
    var label = this.newLabel('optarg-' + name),
        idx   = this.addLocal(name);

    this.optionalArgLabels.push(label);

    return {index: idx, label: label};
  },

  setSplatArg: function(name) {
    this.splatIndex = this.addLocal(name);

    return this;
  },

  labelBodyStart: function() {
    this.bodyStartLabel = this.newLabel('bodystart');

    this.setLabel(this.bodyStartLabel);

    return this.bodyStartLabel;
  },

  addInstruction: function(opcode) {
    var insn = new Instruction(opcode,
      Array.prototype.slice.call(arguments, 1));

    this.instructions.push(insn);
    this.currentStackSize += Instruction.stackDelta(insn);

    if (this.currentStackSize > this.maxStackSize) {
      this.maxStackSize = this.currentStackSize;
    }

    return this;
  },

  newLabel: function(name) {
    return new Label(++this.nextLabelNumber, name);
  },

  setLabel: function(label) {
    label.position = this.currentPosition();
    label.sp = this.currentStackSize;

    this.instructions.push(label);

    return this;
  },

  addCatchEntry: function(type, iseq, start, stop, cont) {
    this.catchEntries.push({
      type: type,
      iseq: iseq,
      start: start,
      stop: stop,
      cont: cont,
      sp: this.currentStackSize
    });

    return this;
  },

  currentPosition: function() {
    return this.instructions.length;
  },

  hasLocal: function(name) {
    return this.localISeq.locals.indexOf(name) !== -1;
  },

  addLocal: function(name) {
    var locals = this.localISeq.locals;
    locals.push(name);
    return locals.length - 1;
  },

  localIndex: function(name) {
    return this.localISeq.locals.indexOf(name);
  },

  #define ISEQ_NAME_IDX      1
  #define ISEQ_TYPE_IDX      2
  #define ISEQ_MAX_STACK_IDX 3
  #define ISEQ_LOCALS_IDX    4
  #define ISEQ_ARGS_IDX      5
  #define ISEQ_CATCH_TBL_IDX 6
  #define ISEQ_BODY_IDX      7

  #define ISEQ_ARGS_NUM_REQ_IDX 0
  #define ISEQ_ARGS_NUM_OPT_IDX 1
  #define ISEQ_ARGS_SPLAT_IDX   2
  #define ISEQ_ARGS_LABELS_IDX  3

  #define CATCH_ENTRY_TYPE_IDX      0
  #define CATCH_ENTRY_ISEQ_IDX      1
  #define CATCH_ENTRY_START_LBL_IDX 2
  #define CATCH_ENTRY_STOP_LBL_IDX  3
  #define CATCH_ENTRY_CONT_LBL_IDX  4
  #define CATCH_ENTRY_SP_IDX        5

  // Converts the ISeq object to a raw instruction sequence executable by the
  // VM.
  //
  // Format is as follows:
  //
  // Index Description
  // ----- ---------------------------------------------------------------------
  // 0     "BullyInstructionSequence"
  // 1     name
  // 2     type (top, class, module, method, or block)
  // 3     maximum stack size
  // 4     array of local variable names
  // 5     arguments description
  // 6     catch table
  // 7     body
  toRaw: function() {
    var args       = new Array(4),
        catchLen   = this.catchEntries.length,
        catchTable = new Array(catchLen),
        nopt       = this.optionalArgLabels.length,
        ic         = this.instructions.length,
        result, catchEntry, i;

    args[ISEQ_ARGS_NUM_REQ_IDX] = this.numRequiredArgs;
    args[ISEQ_ARGS_NUM_OPT_IDX] = nopt;
    args[ISEQ_ARGS_SPLAT_IDX]   = this.splatIndex;
    args[ISEQ_ARGS_LABELS_IDX]  = new Array(nopt + 1);

    // setup args
    if (nopt > 0) {
      for (i = 0; i < nopt; i++) {
        args[ISEQ_ARGS_LABELS_IDX][i] = this.optionalArgLabels[i].toRaw();
      }
      args[ISEQ_ARGS_LABELS_IDX][nopt] = this.bodyStartLabel.toRaw();
    }

    // catch table
    for (i = 0; i < catchLen; i++) {
      catchEntry = this.catchEntries[i];
      catchTable[i] = new Array(
        catchEntry.type,
        catchEntry.iseq.toRaw(),
        catchEntry.start.toRaw(),
        catchEntry.stop.toRaw(),
        catchEntry.cont.toRaw(),
        catchEntry.sp
      );
    }

    result = new Array(
      'BullyInstructionSequence',
      this.name,
      this.type,
      this.maxStackSize,
      this.locals,
      args,
      catchTable,
      new Array(ic)
    );

    for (i = 0; i < ic; i++) {
      result[7][i] = this.instructions[i].toRaw();
    }

    return result;
  }
};

Instruction = function(opcode, operands) {
  this.opcode   = opcode;
  this.operands = operands;

  return this;
};

Instruction.ConstantStackDeltas = {
  nop:               0,
  putnil:            1,
  putstring:         1,
  putbuiltin:        1,
  putcurrentmodule:  1,
  putiseq:           1,
  putobject:         1,
  putself:           1,
  getlocal:          1,
  setlocal:         -1,
  getconstant:       0,
  getdynamic:        1,
  pop:              -1,
  definemethod:     -2,
  branchif:         -1,
  branchunless:     -1,
  jump:              0,
  leave:             0,
  throw:             0
};

Instruction.stackDelta = function(insn) {
  var opcode = insn.opcode, constants = this.ConstantStackDeltas;

  if (insn instanceof Label) { return 0; }
  else if (insn.opcode in constants) { return constants[opcode]; }

  switch (opcode) {
    case 'send':
      return -insn.operands[1];
    default:
      throw new Error('invalid opcode: ' + insn.opcode);
  }
};

Instruction.prototype = {
  toRaw: function() {
    var a = [this.opcode], len = this.operands.length, op, i;

    for (i = 0; i < len; i++) {
      op = this.operands[i];
      a.push(typeof op === 'object' ? op.toRaw() : op);
    }

    return a;
  }
};

Label = function(number, name) {
  this.number   = number;
  this.name     = name || 'label';
  this.position = null;
  this.sp       = null;

  return this;
};

Label.prototype = {
  toRaw: function() {
    return this.name + '-' + this.number;
  }
};

//------------------------------------------------------------------------------

Bully.Compiler = {
  compile: function(node) {
    var iseq = new ISeq('top', '<compiled>');

    COMPILE_NODE(node, iseq, true);

    return iseq.toRaw();
  },

  compileBody: function(node, iseq, push) {
    var lines = node.lines, len = lines.length, i;

    for (i = 0; i < len; i++) {
      COMPILE_NODE(lines[i], iseq, push && (i === len - 1));
    }

    iseq.addInstruction('leave');
  },

  compileCall: function(node, iseq, push) {
    var argLen   = node.args ? node.args.length : 0,
        localIdx, i;

    // check to see if this is actually a local variable reference
    if (!node.expression && !node.args && iseq.hasLocal(node.name)) {
      if (push) { iseq.addInstruction('getlocal', iseq.localIndex(node.name)); }
      return;
    }

    // add receiver
    if (node.expression) {
      COMPILE_NODE(node.expression, iseq, true);
    }
    else {
      iseq.addInstruction('putself');
    }

    // add arguments
    for (i = 0; i < argLen; i += 1) {
      COMPILE_NODE(node.args[i], iseq, true);
    }

    iseq.addInstruction('send', node.name, argLen);

    if (!push) { iseq.addInstruction('pop'); }
  },

  compileParamList: function(node, iseq, push) {
    var nreq = node.required.length,
        nopt = node.optional.length,
        labels = [], optArg, i;

    // setup local variables
    iseq.setRequiredArgs(node.required);

    for (i = 0; i < nopt; i++) {
      optArg = iseq.addOptionalArg(node.optional[i].name);
      iseq.setLabel(optArg.label);
      COMPILE_NODE(node.optional[i].expression, iseq, true);
      iseq.addInstruction('setlocal', optArg.index);
    }

    if (nopt > 0) { iseq.labelBodyStart(); }

    if (node.splat) { iseq.setSplatArg(node.splat); }
  },

  compileDef: function(node, iseq, push) {
    var defiseq = new ISeq('method', node.name);

    if (node.params) { COMPILE_NODE(node.params, defiseq, push); }

    COMPILE_NODE(node.body, defiseq, true);

    iseq.addInstruction('putcurrentmodule');
    iseq.addInstruction('putiseq', defiseq);
    iseq.addInstruction('definemethod', node.name, false);

    if (push) { iseq.addInstruction('putnil'); }
  },

  compileLocalAssign: function(node, iseq, push) {
    var idx = iseq.hasLocal(node.name) ?
      iseq.localIndex(node.name) : iseq.addLocal(node.name);

    COMPILE_NODE(node.expression, iseq, true);

    iseq.addInstruction('setlocal', idx);
  },

  compileNumberLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', parseFloat(node.value));
  },

  compileStringLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putstring', node.value);
  },

  compileTrueLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', true);
  },

  compileFalseLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', false);
  },

  compileIf: function(node, iseq, push) {
    var labels = [], len = node.conditions.length, endLabel, lines, i, j;

    for (i = 0; i < len; i++) { labels.push(iseq.newLabel()); }

    endLabel = node.else_body ? iseq.newLabel() : labels[len - 1];

    for (i = 0; i < len; i++) {
      COMPILE_NODE(node.conditions[i], iseq, true);
      iseq.addInstruction('branchunless', labels[i]);
      COMPILE_NODE(node.bodies[i], iseq, push); 

      if (i !== len - 1 || node.else_body) {
        iseq.addInstruction('jump', endLabel);
      }

      iseq.setLabel(labels[i]);
    }

    if (node.else_body) {
      COMPILE_NODE(node.else_body, iseq, push); 
      iseq.setLabel(endLabel);
    }
  },

  compileConstantRef: function(node, iseq, push) {
    var len = node.names.length, i;

    if (node.global) {
      iseq.addInstruction('putbuiltin', 'Object');
    }
    else {
      iseq.addInstruction('putnil');
    }

    iseq.addInstruction('getconstant', node.names[0]);

    for (i = 1; i < len; i++) {
      iseq.addInstruction('getconstant', node.names[i]);
    }

    if (!push) { iseq.addInstruction('pop'); }
  },

  compileRescueBlock: function(node, iseq, push) {
    var bodyl = iseq.newLabel('body'),
        endl  = iseq.newLabel('end'),
        localIdx, len, i;

    if (node.exception_types) {
      len = node.exception_types.length;

      for (i = 0; i < len; i++) {
        COMPILE_NODE(node.exception_types[i], iseq, true);
        iseq.addInstruction('getdynamic', 0, 0);
        iseq.addInstruction('send', '===', 1);

        if (i === len - 1) {
          iseq.addInstruction('branchunless', endl);
        }
        else {
          iseq.addInstruction('branchif', bodyl);
        }
      }
    }
    else {
      iseq.addInstruction('putbuiltin', 'StandardError');
      iseq.addInstruction('getdynamic', 0, 0);
      iseq.addInstruction('send', '===', 1);
      iseq.addInstruction('branchunless', endl);
    }

    iseq.setLabel(bodyl);

    if (node.name) {
      localIdx = iseq.addLocal(node.name);
      iseq.addInstruction('getdynamic', 0, 0);
      iseq.addInstruction('setlocal', localIdx);
    }

    COMPILE_NODE(node.body, iseq, push);
    iseq.addInstruction('leave');
    iseq.setLabel(endl);
  },

  compileBeginBlock: function(node, iseq, push) {
    var startl     = iseq.newLabel('begin-start'),
        endl       = iseq.newLabel('begin-end'), 
        afterl     = iseq.newLabel('begin-after'),
        rescuesLen = node.rescues.length,
        rescueISeq, i;

    // add catch table entries, this must be done before compiling the body of
    // the begin block
    if (rescuesLen > 0) {
      rescueISeq = iseq.newChildISeq('rescue', 'rescue in ' + iseq.name);

      for (i = 0; i < rescuesLen; i++) {
        COMPILE_NODE(node.rescues[i], rescueISeq, push);
      }

      rescueISeq.addInstruction('getdynamic', 2, 0);
      rescueISeq.addInstruction('throw');

      iseq.addCatchEntry('rescue', rescueISeq, startl, endl, afterl);
    }

    iseq.setLabel(startl);
    COMPILE_NODE(node.body, iseq, push);
    iseq.setLabel(endl);
    // TODO: compile else and ensure if present
    iseq.setLabel(afterl);
  },

  nextLabel: function() {
    this.nextLabelId++;
    return 'label_' + this.nextLabelId;
  }
};

}());

