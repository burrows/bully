
#define COMPILE_NODE(node, ...) this['compile' + (node).type](node, ##__VA_ARGS__)

#define VM_THROW_TYPE_RAISE 0
#define VM_THROW_TYPE_RETRY 4

(function() {

var ISeq, Instruction, Label;

ISeq = function(type, name) {
  this.name              = name;
  this.type              = type;
  this.instructions      = [];
  this.parentISeq        = null;
  this.localISeq         = this;
  this.numRequiredArgs   = 0;
  this.optionalArgLabels = [];
  this.bodyStartLabel    = null;
  this.splatIndex        = -1;
  this.locals            = [];
  this.catchEntries      = [];
  this.currentStackSize  = 0;
  this.maxStackSize      = 0;

  return this;
};

ISeq.prototype = {
  newChildISeq: function(type, name) {
    var iseq = new ISeq(type, name);

    iseq.parentISeq = this;

    if (type === 'rescue') {
      iseq.localISeq = this;
    }
    else {
      iseq.localISeq = iseq;
    }

    return iseq;
  },

  setRequiredArgs: function(argNames) {
    var len = argNames.length, i;

    this.numRequiredArgs = len;

    for (i = 0; i < len; i++) {
      this.addLocal(argNames[i]);
    }

    return this;
  },

  addOptionalArg: function(name) {
    var label = new Label('optarg-' + name),
        idx   = this.addLocal(name);

    this.optionalArgLabels.push(label);

    return {index: idx, label: label};
  },

  setSplatArg: function(name) {
    this.splatIndex = this.addLocal(name);

    return this;
  },

  labelBodyStart: function() {
    this.bodyStartLabel = new Label('bodystart');

    this.setLabel(this.bodyStartLabel);

    return this.bodyStartLabel;
  },

  addInstruction: function(opcode) {
    var insn = new Instruction(opcode,
      Array.prototype.slice.call(arguments, 1));

    this.instructions.push(insn);
    this.currentStackSize += Instruction.stackDelta(insn);

    if (this.currentStackSize > this.maxStackSize) {
      this.maxStackSize = this.currentStackSize;
    }

    return this;
  },

  setLabel: function(label) {
    label.position = this.currentPosition();
    label.sp = this.currentStackSize;

    this.instructions.push(label);

    return this;
  },

  addCatchEntry: function(type, iseq, start, stop, cont, sp) {
    this.catchEntries.push({
      type: type,
      iseq: iseq,
      start: start,
      stop: stop,
      cont: cont,
      sp: sp 
    });

    return this;
  },

  currentPosition: function() {
    return this.instructions.length;
  },

  hasLocal: function(name) {
    return this.localISeq.locals.indexOf(name) !== -1;
  },

  addLocal: function(name) {
    var locals = this.localISeq.locals;
    locals.push(name);
    return locals.length - 1;
  },

  localIndex: function(name) {
    return this.localISeq.locals.indexOf(name);
  },

  #define ISEQ_NAME_IDX      1
  #define ISEQ_TYPE_IDX      2
  #define ISEQ_MAX_STACK_IDX 3
  #define ISEQ_LOCALS_IDX    4
  #define ISEQ_ARGS_IDX      5
  #define ISEQ_CATCH_TBL_IDX 6
  #define ISEQ_BODY_IDX      7

  #define ISEQ_ARGS_NUM_REQ_IDX 0
  #define ISEQ_ARGS_NUM_OPT_IDX 1
  #define ISEQ_ARGS_SPLAT_IDX   2
  #define ISEQ_ARGS_LABELS_IDX  3

  #define CATCH_ENTRY_TYPE_IDX      0
  #define CATCH_ENTRY_ISEQ_IDX      1
  #define CATCH_ENTRY_START_LBL_IDX 2
  #define CATCH_ENTRY_STOP_LBL_IDX  3
  #define CATCH_ENTRY_CONT_LBL_IDX  4
  #define CATCH_ENTRY_SP_IDX        5

  // Converts the ISeq object to a raw instruction sequence executable by the
  // VM.
  //
  // Format is as follows:
  //
  // Index Description
  // ----- ---------------------------------------------------------------------
  // 0     "BullyInstructionSequence"
  // 1     name
  // 2     type (top, class, module, method, or block)
  // 3     maximum stack size
  // 4     array of local variable names
  // 5     arguments description
  // 6     catch table
  // 7     body
  toRaw: function() {
    var args       = new Array(4),
        catchLen   = this.catchEntries.length,
        catchTable = new Array(catchLen),
        nopt       = this.optionalArgLabels.length,
        ic         = this.instructions.length,
        result, catchEntry, i;

    args[ISEQ_ARGS_NUM_REQ_IDX] = this.numRequiredArgs;
    args[ISEQ_ARGS_NUM_OPT_IDX] = nopt;
    args[ISEQ_ARGS_SPLAT_IDX]   = this.splatIndex;
    args[ISEQ_ARGS_LABELS_IDX]  = new Array(nopt + 1);

    // setup args
    if (nopt > 0) {
      for (i = 0; i < nopt; i++) {
        args[ISEQ_ARGS_LABELS_IDX][i] = this.optionalArgLabels[i].toRaw();
      }
      args[ISEQ_ARGS_LABELS_IDX][nopt] = this.bodyStartLabel.toRaw();
    }

    // catch table
    for (i = 0; i < catchLen; i++) {
      catchEntry = this.catchEntries[i];
      catchTable[i] = new Array(
        catchEntry.type,
        catchEntry.iseq ? catchEntry.iseq.toRaw() : null,
        catchEntry.start.toRaw(),
        catchEntry.stop.toRaw(),
        catchEntry.cont.toRaw(),
        catchEntry.sp
      );
    }

    result = new Array(
      'BullyInstructionSequence',
      this.name,
      this.type,
      this.maxStackSize,
      this.locals,
      args,
      catchTable,
      new Array(ic)
    );

    for (i = 0; i < ic; i++) {
      result[7][i] = this.instructions[i].toRaw();
    }

    return result;
  }
};

Instruction = function(opcode, operands) {
  this.opcode   = opcode;
  this.operands = operands;

  return this;
};

Instruction.ConstantStackDeltas = {
  nop:               0,
  putnil:            1,
  putstring:         1,
  putsymbol:         1,
  putbuiltin:        1,
  putcurrentmodule:  1,
  putiseq:           1,
  putobject:         1,
  putself:           1,
  getlocal:          1,
  setlocal:         -1,
  getconstant:       0,
  getdynamic:        1,
  pop:              -1,
  dup:               1,
  definemethod:     -2,
  branchif:         -1,
  branchunless:     -1,
  jump:              0,
  leave:             0,
  throw:             0
};

Instruction.stackDelta = function(insn) {
  var opcode = insn.opcode, constants = this.ConstantStackDeltas;

  if (insn instanceof Label) { return 0; }
  else if (insn.opcode in constants) { return constants[opcode]; }

  switch (opcode) {
    case 'send':
      return -insn.operands[1];
    case 'newarray':
      return insn.operands[0] - 1;
    default:
      throw new Error('invalid opcode: ' + insn.opcode);
  }
};

Instruction.prototype = {
  toRaw: function() {
    var a = [this.opcode], len = this.operands.length, op, i;

    for (i = 0; i < len; i++) {
      op = this.operands[i];
      a.push(typeof op === 'object' ? op.toRaw() : op);
    }

    return a;
  }
};

Label = function(name) {
  this.name     = name || 'label';
  this.position = null;
  this.sp       = null;

  return this;
};

Label.prototype = {
  toRaw: function() {
    if (this.position === null) {
      throw new Error('Label#toRaw: label has not been set: ' + this.name);
    }
    return this.name + '-' + this.position;
  }
};

//------------------------------------------------------------------------------

Bully.Compiler = {
  compile: function(node) {
    var iseq = new ISeq('top', '<compiled>');

    COMPILE_NODE(node, iseq, true);
    iseq.addInstruction('leave');

    return iseq.toRaw();
  },

  compileBody: function(node, iseq, push) {
    var lines = node.lines, len = lines.length, i;

    if (len === 0) {
      iseq.addInstruction('putnil');
      return;
    }

    for (i = 0; i < len; i++) {
      COMPILE_NODE(lines[i], iseq, push && (i === len - 1));
    }
  },

  compileCall: function(node, iseq, push) {
    var argLen = node.args ? node.args.length : 0, i;

    // check to see if this is actually a local variable reference
    if (!node.expression && !node.args && iseq.hasLocal(node.name)) {
      if (push) { iseq.addInstruction('getlocal', iseq.localIndex(node.name)); }
      return;
    }

    // add receiver
    if (node.expression) {
      COMPILE_NODE(node.expression, iseq, true);
    }
    else {
      iseq.addInstruction('putself');
    }

    // add arguments
    for (i = 0; i < argLen; i += 1) {
      COMPILE_NODE(node.args[i], iseq, true);
    }

    iseq.addInstruction('send', node.name, argLen);

    if (!push) { iseq.addInstruction('pop'); }
  },

  compileParamList: function(node, iseq, push) {
    var nreq = node.required.length,
        nopt = node.optional.length,
        labels = [], optArg, i;

    // setup local variables
    iseq.setRequiredArgs(node.required);

    for (i = 0; i < nopt; i++) {
      optArg = iseq.addOptionalArg(node.optional[i].name);
      iseq.setLabel(optArg.label);
      COMPILE_NODE(node.optional[i].expression, iseq, true);
      iseq.addInstruction('setlocal', optArg.index);
    }

    if (nopt > 0) { iseq.labelBodyStart(); }

    if (node.splat) { iseq.setSplatArg(node.splat); }
  },

  compileDef: function(node, iseq, push) {
    var defiseq = new ISeq('method', node.name);

    if (node.params) { COMPILE_NODE(node.params, defiseq, push); }

    COMPILE_NODE(node.body, defiseq, true);
    defiseq.addInstruction('leave');

    iseq.addInstruction('putcurrentmodule');
    iseq.addInstruction('putiseq', defiseq);
    iseq.addInstruction('definemethod', node.name, false);

    if (push) { iseq.addInstruction('putnil'); }
  },

  compileLocalAssign: function(node, iseq, push) {
    var idx = iseq.hasLocal(node.name) ?
      iseq.localIndex(node.name) : iseq.addLocal(node.name);

    COMPILE_NODE(node.expression, iseq, true);

    // ensure that there is a value left on the stack
    if (push) { iseq.addInstruction('dup'); }

    iseq.addInstruction('setlocal', idx);
  },

  compileNilLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putnil');
  },

  compileNumberLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', parseFloat(node.value));
  },

  compileStringLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putstring', node.value);
  },

  compileTrueLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', true);
  },

  compileFalseLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putobject', false);
  },

  compileSymbolLiteral: function(node, iseq, push) {
    if (!push) { return; }
    iseq.addInstruction('putsymbol', node.value.slice(1));
  },

  compileArrayLiteral: function(node, iseq, push) {
    var i, len;
    if (!push) { return; }

    len = node.expressions.length;

    for (i = 0; i < len; i++) {
      COMPILE_NODE(node.expressions[i], iseq, push);
    }

    iseq.addInstruction('newarray', len);
  },

  compileIf: function(node, iseq, push) {
    var labels = [], len = node.conditions.length, endLabel, lines, i, j;

    for (i = 0; i < len; i++) { labels.push(new Label()); }

    endLabel = node.else_body ? new Label() : labels[len - 1];

    for (i = 0; i < len; i++) {
      COMPILE_NODE(node.conditions[i], iseq, true);
      iseq.addInstruction('branchunless', labels[i]);
      COMPILE_NODE(node.bodies[i], iseq, push); 

      if (i !== len - 1 || node.else_body) {
        iseq.addInstruction('jump', endLabel);
      }

      iseq.setLabel(labels[i]);
    }

    if (node.else_body) {
      COMPILE_NODE(node.else_body, iseq, push); 
      iseq.setLabel(endLabel);
    }
  },

  compileConstantRef: function(node, iseq, push) {
    var len = node.names.length, i;

    if (node.global) {
      iseq.addInstruction('putbuiltin', 'Object');
    }
    else {
      iseq.addInstruction('putnil');
    }

    iseq.addInstruction('getconstant', node.names[0]);

    for (i = 1; i < len; i++) {
      iseq.addInstruction('getconstant', node.names[i]);
    }

    if (!push) { iseq.addInstruction('pop'); }
  },

  compileRescueBlocks: function(rescues, iseq) {
    var len = rescues.length, startl, nextl, node, types, typeslen, idx, i, j;

    // Rescue blocks always have a 'private' local varable (not available from
    // Bully code) that contains a reference to the exception object. We can't
    // use addLocal here because rescue ISeq objects store all of their local
    // variables in their parent ISeq so we have to forcefully add it to this
    // ISeq's locals array.
    iseq.locals[0] = '#$!';

    for (i = 0; i < len; i++) {
      node   = rescues[i];
      startl = new Label('start');
      nextl  = new Label('next');

      if (node.exception_types) {
        types    = node.exception_types;
        typeslen = types.length;

        for (j = 0; j < typeslen; j++) {
          COMPILE_NODE(types[j], iseq, true);
          iseq.addInstruction('getdynamic', 0, 0);
          iseq.addInstruction('send', '===', 1);
          iseq.addInstruction('branchif', startl);
        }
      }
      else {
        iseq.addInstruction('putbuiltin', 'StandardError');
        iseq.addInstruction('getdynamic', 0, 0);
        iseq.addInstruction('send', '===', 1);
        iseq.addInstruction('branchif', startl);
      }

      iseq.addInstruction('jump', nextl);
      iseq.setLabel(startl);

      if (node.name) {
        idx = iseq.hasLocal(node.name) ? iseq.localIndex(node.name) :
          iseq.addLocal(node.name);

        iseq.addInstruction('getdynamic', 0, 0);
        iseq.addInstruction('setlocal', idx);
      }

      COMPILE_NODE(node.body, iseq, true);
      iseq.addInstruction('leave');
      iseq.setLabel(nextl);
    }

    iseq.addInstruction('getdynamic', 0, 0);
    iseq.addInstruction('throw', VM_THROW_TYPE_RAISE);
  },

  compileEnsureBlock: function(node, iseq) {
    iseq.locals[0] = '#$!';
    COMPILE_NODE(node, iseq, false);
    iseq.addInstruction('getdynamic', 0, 0);
    iseq.addInstruction('throw', VM_THROW_TYPE_RAISE);
  },

  compileBeginBlock: function(node, iseq, push) {
    var rescuesLen = node.rescues.length,
        hasRescue  = rescuesLen > 0,
        hasElse    = !!node.else_body,
        hasEnsure  = !!node.ensure,
        labels     = {},
        sp         = iseq.currentStackSize,
        riseq, eiseq;

    if (!hasRescue && !hasEnsure && !hasElse) {
      COMPILE_NODE(node.body, iseq, push);
      return;
    }

    if (hasRescue) {
      labels.rstart = new Label('rstart');
      labels.rstop  = new Label('rstop');
      labels.rcont  = new Label('rcont');
    }

    if (hasEnsure) {
      labels.estart = hasRescue ? labels.rstart : new Label('estart');
      labels.estop  = (hasRescue && push) ? labels.rcont : new Label('estop');
      labels.econt  = new Label('econt');
    }

    if (hasRescue)               { iseq.setLabel(labels.rstart); }
    if (hasEnsure && !hasRescue) { iseq.setLabel(labels.estart); }

    COMPILE_NODE(node.body, iseq, true);

    if (hasRescue)             { iseq.setLabel(labels.rstop); }
    if (hasRescue && !hasElse) { iseq.setLabel(labels.rcont); }
    if (hasElse || !push)      { iseq.addInstruction('pop'); }

    if (hasElse) {
      COMPILE_NODE(node.else_body, iseq, true);
      if (hasRescue) { iseq.setLabel(labels.rcont); }
      if (!push)     { iseq.addInstruction('pop') }
    }

    if (hasEnsure) {
      if (labels.estop !== labels.rcont) { iseq.setLabel(labels.estop); }
      COMPILE_NODE(node.ensure, iseq, false); // ensure result is always discarded
      iseq.setLabel(labels.econt);
    }

    if (hasRescue) {
      riseq = iseq.newChildISeq('rescue', 'rescue in ' + iseq.name);
      this.compileRescueBlocks(node.rescues, riseq);
      iseq.addCatchEntry('rescue', riseq, labels.rstart, labels.rstop, labels.rcont, sp);
      iseq.addCatchEntry('retry', null, labels.rstop, labels.rcont, labels.rstart, sp);
    }

    if (hasEnsure) {
      eiseq = iseq.newChildISeq('ensure', 'ensure in ' + iseq.name);
      this.compileEnsureBlock(node.ensure, eiseq);
      iseq.addCatchEntry('ensure', eiseq, labels.estart, labels.estop, labels.econt, sp);
    }
  },

  compileRetry: function(node, iseq) {
    iseq.addInstruction('putnil');
    iseq.addInstruction('throw', VM_THROW_TYPE_RETRY);
  }
};

}());

