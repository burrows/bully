
#define COMPILE_NODE(node, ...) this['compile' + (node).type](node, ##__VA_ARGS__)

(function() {

var ISeqContext = function(opts) {
  opts = opts || {};

  this.name   = opts.name   || "";
  this.type   = opts.type   || "";
  this.locals = opts.locals || [];
  this.args   = opts.args   || 0;

  return this;
};

ISeqContext.prototype = {
};

Bully.Compiler = {
  compile: function(node) {
    var ctx = new ISeqContext({ name: '<compiled>', type: 'top' });
    return this.compileBody(node, ctx);
  },

  #define ISEQ_NAME_IDX   1
  #define ISEQ_TYPE_IDX   2
  #define ISEQ_LOCALS_IDX 3
  #define ISEQ_ARGS_IDX   4
  #define ISEQ_BODY_IDX   5

  // Compiles a Body node into an instruction sequence.  The format is as
  // follows:
  //
  // Index Description
  // ----- ---------------------------------------------------------------------
  // 0     opcode (iseq)
  // 1     name
  // 2     type (top, class, module, method, block)
  // 3     array of local variable names
  // 4     arguments description
  // 5     instruction sequence body
  compileBody: function(node, ctx) {
    var len = node.lines.length, body = [], i;

    for (i = 0; i < len; i += 1) {
      COMPILE_NODE(node.lines[i], body, ctx);
    }

    return [
      'iseq',
      ctx.name,
      ctx.type,
      ctx.locals,
      ctx.args,
      body
    ];
  },

  compileCall: function(node, iseq, ctx) {
    var argLen   = node.args ? node.args.length : 0,
        localIdx = ctx.locals.indexOf(node.name),
        i;

    // check to see if this is actually a local variable reference
    if (!node.expression && !node.args && localIdx !== -1) {
      iseq.push(['getlocal', localIdx]);
      return;
    }

    // add receiver
    if (node.expression) {
      COMPILE_NODE(node.expression, iseq, ctx);
    }
    else {
      iseq.push(['putnil']);
    }

    // add arguments
    for (i = 0; i < argLen; i += 1) {
      COMPILE_NODE(node.args[i], iseq, ctx);
    }

    iseq.push(['send', node.name, argLen]);
  },

  compileParamList: function(node, iseq, ctx) {
    ctx.locals = ctx.locals.concat(node.required);
    ctx.args = node.required.length;
  },

  compileDef: function(node, iseq) {
    var ctx = new ISeqContext({name: node.name, type: 'method'});

    if (node.params) {
      this.compileParamList(node.params, iseq, ctx);
    }

    body = this.compileBody(node.body, ctx);

    iseq.push(['putcurrentmodule']);
    iseq.push(['putiseq', body])
    iseq.push(['definemethod', node.name, false]);
  },

  compileLocalAssign: function(node, iseq, ctx) {
    var idx = ctx.locals.length;

    ctx.locals.push(node.name);

    COMPILE_NODE(node.expression, iseq, ctx);
    iseq.push(['setlocal', idx]);
  },

  compileNumberLiteral: function(node, iseq) {
    iseq.push(['putobject', parseFloat(node.value)]);
  }
};

})();
